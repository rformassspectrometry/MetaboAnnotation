[{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Annotation of MS-based Metabolomics Data","text":"MetaboAnnotation package defines high-level user functionality support facilitate annotation MS-based metabolomics data (Rainer et al. 2022).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Annotation of MS-based Metabolomics Data","text":"package can installed BiocManager package. install BiocManager use install.packages(\"BiocManager\") , , BiocManager::install(\"MetaboAnnotation\") install package.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"general-description","dir":"Articles","previous_headings":"","what":"General description","title":"Annotation of MS-based Metabolomics Data","text":"MetaboAnnotation provides set matching functions allow comparison (matching) query target entities. entities can chemical formulas, numeric values (e.g. m/z retention times) fragment spectra. available matching functions : matchFormula(): match chemical formulas. matchSpectra(): match fragment spectra. matchValues() (formerly matchMz()): match numerical values (m/z, masses, retention times etc). matching functions parameter objects available allow different types matching algorithms. Refer help pages detailed listing (e.g. ?matchFormula, ?matchSpectra ?matchValues). result, Matched (MatchedSpectra) object returned streamlines simplifies handling potential one--many (one--none) matching.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"example-use-cases","dir":"Articles","previous_headings":"","what":"Example use cases","title":"Annotation of MS-based Metabolomics Data","text":"following sections illustrate example use cases functionality provided MetaboAnnotation package.","code":"library(MetaboAnnotation)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-mz-values","dir":"Articles","previous_headings":"Example use cases","what":"Matching of m/z values","title":"Annotation of MS-based Metabolomics Data","text":"section simple matching feature m/z values theoretical m/z values performed. lowest level confidence metabolite annotation. However, gives ideas potential metabolites can analyzed downstream experiments analyses. following example loads feature table lipidomics experiments matches measured m/z values reference masses LipidMaps. use data.frame reference database, CompDb compound database instance (created CompoundDb package) also supported. reference (target) compounds mass available. need convert mass m/z values order match m/z values features (.e. query m/z values) . need define likely ions/adducts generated compounds based ionization used experiment. assume abundant adducts compounds \"[M+H]+\" \"[M+Na]+. next perform matching matchValues() function providing query target data well parameter object (case Mass2MzParam) settings matching. Mass2MzParam, mass target compounds get first converted m/z values, based defined adducts, matched query m/z values (.e. m/z values features). get full list supported adducts MetaboCoreUtils::adductNames(polarity = \"positive\") MetaboCoreUtils::adductNames(polarity = \"negative\") can used). Note also, keep runtime vignette short, match first 100 features. tested 100 features 55 matched least one target compound (matches single compound). result object (type Matched) contains full query data frame target data frames well matching information. can access original query data query() original target data target() function: Functions whichQuery() whichTarget() can used identify rows query target data matched: colnames function can used evaluate variables/columns available Matched object. columns query, columns target (prefix \"target_\" added original column names target) information matching result (case columns \"adduct\", \"score\" \"ppm_error\"). can extract full matching table matchedData(). returns DataFrame rows query corresponding matches target along matching adduct (column \"adduct\") difference m/z (column \"score\" absolute differences \"ppm_error\" m/z relative differences). Note row query matches multiple elements target, row duplicated DataFrame returned matchedData(). rows can matched NA values reported. Individual columns can simply extracted $ operator: NA reported query entries match found. See also help page ?Matched details information. addition matching query m/z target exact masses described also possible match directly query m/z target m/z values using MzParam instead Mass2MzParam.","code":"ms1_features <- read.table(system.file(\"extdata\", \"MS1_example.txt\",                                        package = \"MetaboAnnotation\"),                            header = TRUE, sep = \"\\t\") head(ms1_features) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 target_df <- read.table(system.file(\"extdata\", \"LipidMaps_CompDB.txt\",                                     package = \"MetaboAnnotation\"),                         header = TRUE, sep = \"\\t\") head(target_df) ##   headgroup        name exactmass    formula chain_type ## 1       NAE  NAE 20:4;O  363.2773  C22H37NO3       even ## 2       NAT  NAT 20:4;O  427.2392 C22H37NO5S       even ## 3       NAE NAE 20:3;O2  381.2879  C22H39NO4       even ## 4       NAE    NAE 20:4  347.2824  C22H37NO2       even ## 5       NAE    NAE 18:2  323.2824  C20H37NO2       even ## 6       NAE    NAE 18:3  321.2668  C20H35NO2       even parm <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                            tolerance = 0.005, ppm = 0)  matched_features <- matchValues(ms1_features[1:100, ], target_df, parm) matched_features ## Object of class Matched  ## Total number of matches: 55  ## Number of query objects: 100 (55 matched) ## Number of target objects: 57599 (1 matched) head(query(matched_features)) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 head(target(matched_features)) ##   headgroup        name exactmass    formula chain_type ## 1       NAE  NAE 20:4;O  363.2773  C22H37NO3       even ## 2       NAT  NAT 20:4;O  427.2392 C22H37NO5S       even ## 3       NAE NAE 20:3;O2  381.2879  C22H39NO4       even ## 4       NAE    NAE 20:4  347.2824  C22H37NO2       even ## 5       NAE    NAE 18:2  323.2824  C20H37NO2       even ## 6       NAE    NAE 18:3  321.2668  C20H35NO2       even whichQuery(matched_features) ##  [1]  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64 ## [20]  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83 ## [39]  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 whichTarget(matched_features) ## [1] 3149 colnames(matched_features) ##  [1] \"feature_id\"        \"mz\"                \"rtime\"             ##  [4] \"target_headgroup\"  \"target_name\"       \"target_exactmass\"  ##  [7] \"target_formula\"    \"target_chain_type\" \"adduct\"            ## [10] \"score\"             \"ppm_error\" matchedData(matched_features) ## DataFrame with 100 rows and 11 columns ##        feature_id        mz     rtime target_headgroup target_name ##       <character> <numeric> <numeric>      <character> <character> ## 1   Cluster_00...   102.128   1.56015               NA          NA ## 2   Cluster_00...   102.128   2.15359               NA          NA ## 3   Cluster_00...   102.128   2.92557               NA          NA ## 4   Cluster_00...   102.128   3.41962               NA          NA ## 5   Cluster_00...   102.127   5.80104               NA          NA ## ...           ...       ...       ...              ...         ... ## 96  Cluster_00...   201.113   11.2722               FA  FA 10:2;O2 ## 97  Cluster_00...   201.113   11.4081               FA  FA 10:2;O2 ## 98  Cluster_00...   201.113   11.4760               FA  FA 10:2;O2 ## 99  Cluster_00...   201.114   11.5652               FA  FA 10:2;O2 ## 100 Cluster_01...   201.114   11.7752               FA  FA 10:2;O2 ##     target_exactmass target_formula target_chain_type      adduct     score ##            <numeric>    <character>       <character> <character> <numeric> ## 1                 NA             NA                NA          NA        NA ## 2                 NA             NA                NA          NA        NA ## 3                 NA             NA                NA          NA        NA ## 4                 NA             NA                NA          NA        NA ## 5                 NA             NA                NA          NA        NA ## ...              ...            ...               ...         ...       ... ## 96           200.105       C10H16O4              even      [M+H]+ 0.0007312 ## 97           200.105       C10H16O4              even      [M+H]+ 0.0005444 ## 98           200.105       C10H16O4              even      [M+H]+ 0.0005328 ## 99           200.105       C10H16O4              even      [M+H]+ 0.0014619 ## 100          200.105       C10H16O4              even      [M+H]+ 0.0020342 ##     ppm_error ##     <numeric> ## 1          NA ## 2          NA ## 3          NA ## 4          NA ## 5          NA ## ...       ... ## 96    3.63578 ## 97    2.70695 ## 98    2.64927 ## 99    7.26908 ## 100  10.11476 matched_features$target_name ##   [1] NA           NA           NA           NA           NA           ##   [6] NA           NA           NA           NA           NA           ##  [11] NA           NA           NA           NA           NA           ##  [16] NA           NA           NA           NA           NA           ##  [21] NA           NA           NA           NA           NA           ##  [26] NA           NA           NA           NA           NA           ##  [31] NA           NA           NA           NA           NA           ##  [36] NA           NA           NA           NA           NA           ##  [41] NA           NA           NA           NA           NA           ##  [46] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [51] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [56] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [61] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [66] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [71] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [76] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [81] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [86] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [91] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" ##  [96] \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\" \"FA 10:2;O2\""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-mz-and-retention-time-values","dir":"Articles","previous_headings":"Example use cases","what":"Matching of m/z and retention time values","title":"Annotation of MS-based Metabolomics Data","text":"expected retention time values available target compounds, annotation higher confidence performed matchValues() Mass2MzRtParam parameter object. illustrate randomly assign retention times query features target compounds adding also 2 seconds difference. real use case target data.frame contain masses (m/z values) standards along retention times ions standards measured LC-MS setup query data derives. subset data table MS1 features first 100 rows (keep runtime vignette short). table contains thus retention times features column named \"rtime\". Next randomly assign retention times features compounds target data adding deviation 2 seconds. described , real use case retention times supposed determined measuring compounds LC-MS setup. now retention times available query target data can thus perform matching based m/z retention times. use Mass2MzRtParam allows us specify (Mass2MzParam) expected adducts, maximal acceptable m/z relative absolute deviation well maximal acceptable (absolute) difference retention times. use settings previous section allow difference 10 seconds retention times. retention times provided columns named \"rtime\" different default (\"rt\"). thus specify name column containing retention times parameter rtColname. Less features matched based m/z retention times.","code":"ms1_subset <- ms1_features[1:100, ] head(ms1_subset) ##     feature_id       mz    rtime ## 1 Cluster_0001 102.1281 1.560147 ## 2 Cluster_0002 102.1279 2.153590 ## 3 Cluster_0003 102.1281 2.925570 ## 4 Cluster_0004 102.1281 3.419617 ## 5 Cluster_0005 102.1270 5.801039 ## 6 Cluster_0006 102.1230 8.137535 set.seed(123) target_df$rtime <- sample(ms1_subset$rtime,                           nrow(target_df), replace = TRUE) + 2 parm <- Mass2MzRtParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                        tolerance = 0.005, ppm = 0,                        toleranceRt = 10) matched_features <- matchValues(ms1_subset, target_df, param = parm,                                 rtColname = \"rtime\") matched_features ## Object of class Matched  ## Total number of matches: 31  ## Number of query objects: 100 (31 matched) ## Number of target objects: 57599 (1 matched) matchedData(matched_features)[whichQuery(matched_features), ] ## DataFrame with 31 rows and 13 columns ##        feature_id        mz     rtime target_headgroup target_name ##       <character> <numeric> <numeric>      <character> <character> ## 1   Cluster_00...   201.113   5.87206               FA  FA 10:2;O2 ## 2   Cluster_00...   201.113   5.93346               FA  FA 10:2;O2 ## 3   Cluster_00...   201.113   6.03653               FA  FA 10:2;O2 ## 4   Cluster_00...   201.114   6.16709               FA  FA 10:2;O2 ## 5   Cluster_00...   201.113   6.31781               FA  FA 10:2;O2 ## ...           ...       ...       ...              ...         ... ## 27  Cluster_00...   201.113   11.2722               FA  FA 10:2;O2 ## 28  Cluster_00...   201.113   11.4081               FA  FA 10:2;O2 ## 29  Cluster_00...   201.113   11.4760               FA  FA 10:2;O2 ## 30  Cluster_00...   201.114   11.5652               FA  FA 10:2;O2 ## 31  Cluster_01...   201.114   11.7752               FA  FA 10:2;O2 ##     target_exactmass target_formula target_chain_type target_rtime      adduct ##            <numeric>    <character>       <character>    <numeric> <character> ## 1            200.105       C10H16O4              even      15.8624      [M+H]+ ## 2            200.105       C10H16O4              even      15.8624      [M+H]+ ## 3            200.105       C10H16O4              even      15.8624      [M+H]+ ## 4            200.105       C10H16O4              even      15.8624      [M+H]+ ## 5            200.105       C10H16O4              even      15.8624      [M+H]+ ## ...              ...            ...               ...          ...         ... ## 27           200.105       C10H16O4              even      15.8624      [M+H]+ ## 28           200.105       C10H16O4              even      15.8624      [M+H]+ ## 29           200.105       C10H16O4              even      15.8624      [M+H]+ ## 30           200.105       C10H16O4              even      15.8624      [M+H]+ ## 31           200.105       C10H16O4              even      15.8624      [M+H]+ ##         score ppm_error  score_rt ##     <numeric> <numeric> <numeric> ## 1   0.0004538   2.25645  -9.99030 ## 2   0.0004407   2.19131  -9.92890 ## 3   0.0005655   2.81186  -9.82583 ## 4   0.0015560   7.73698  -9.69527 ## 5   0.0006845   3.40357  -9.54455 ## ...       ...       ...       ... ## 27  0.0007312   3.63578  -4.59014 ## 28  0.0005444   2.70695  -4.45431 ## 29  0.0005328   2.64927  -4.38634 ## 30  0.0014619   7.26908  -4.29719 ## 31  0.0020342  10.11476  -4.08719"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-summarizedexperiment-or-qfeatures-objects","dir":"Articles","previous_headings":"Example use cases","what":"Matching of SummarizedExperiment or QFeatures objects","title":"Annotation of MS-based Metabolomics Data","text":"Results LC-MS preprocessing (e.g. xcms package) generally metabolomics results might best represented bundled SummarizedExperiment QFeatures objects (-named Bioconductor packages). XCMSnExp preprocessing result xcms can example converted SummarizedExperiment using quantify() method xcms package. feature definitions (.e. m/z retention time values) stored object’s rowData() assay (numerical matrix) contain feature abundances across samples. SummarizedExperiment objects can simply passed query objects matchValues() method. illustrate , create simple SummarizedExperiment using ms1_features data frame example rowData adding matrix random values assay. can now use matchValues() call perform matching. Matching performed object’s rowData, .e. row/element SummarizedExperiment matched target using e.g. m/z values available columns object’s rowData: query, result contains full SummarizedExperiment, colnames() matchedData() access respective information rowData SummarizedExperiment: Subsetting result object, e.g. just matched elements also subset SummarizedExperiment. QFeatures object essentially container several SummarizedExperiment objects rows (features) related . object thus example contain full feature data LC-MS experiment one assay compounded feature data data ions compound aggregated additional assay. create object using SummarizedExperiment assay name \"features\". now don’t add additional assay QFeatures, thus, object contains single data set. matchValues() supports also matching QFeatures objects user needs define assay used matching queryAssay parameter. colnames() matchedData() allow access rowData SummarizedExperiment stored QFeatures’ \"features\" assay:","code":"library(SummarizedExperiment) ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ##  ## Attaching package: 'MatrixGenerics' ## The following objects are masked from 'package:matrixStats': ##  ##     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ##     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ##     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ##     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ##     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ##     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ##     colWeightedMeans, colWeightedMedians, colWeightedSds, ##     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ##     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ##     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ##     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ##     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ##     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ##     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ##     rowWeightedSds, rowWeightedVars ## Loading required package: GenomicRanges ## Loading required package: IRanges ## Loading required package: GenomeInfoDb ## Loading required package: Biobase ## Welcome to Bioconductor ##  ##     Vignettes contain introductory material; view with ##     'browseVignettes()'. To cite Bioconductor, see ##     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. ##  ## Attaching package: 'Biobase' ## The following object is masked from 'package:MatrixGenerics': ##  ##     rowMedians ## The following objects are masked from 'package:matrixStats': ##  ##     anyMissing, rowMedians ## The following object is masked from 'package:AnnotationHub': ##  ##     cache se <- SummarizedExperiment(     assays = matrix(rnorm(nrow(ms1_features) * 4), ncol = 4,                     dimnames = list(NULL, c(\"A\", \"B\", \"C\", \"D\"))),     rowData = ms1_features) parm <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),                      tolerance = 0.005, ppm = 0) matched_features <- matchValues(se, target_df, param = parm) matched_features ## Object of class Matched  ## Total number of matches: 9173  ## Number of query objects: 2842 (1969 matched) ## Number of target objects: 57599 (3296 matched) colnames(matched_features) ##  [1] \"feature_id\"        \"mz\"                \"rtime\"             ##  [4] \"target_headgroup\"  \"target_name\"       \"target_exactmass\"  ##  [7] \"target_formula\"    \"target_chain_type\" \"target_rtime\"      ## [10] \"adduct\"            \"score\"             \"ppm_error\" matchedData(matched_features) ## DataFrame with 10046 rows and 12 columns ##          feature_id        mz     rtime target_headgroup   target_name ##         <character> <numeric> <numeric>      <character>   <character> ## 1     Cluster_00...   102.128   1.56015               NA            NA ## 2     Cluster_00...   102.128   2.15359               NA            NA ## 3     Cluster_00...   102.128   2.92557               NA            NA ## 4     Cluster_00...   102.128   3.41962               NA            NA ## 5     Cluster_00...   102.127   5.80104               NA            NA ## ...             ...       ...       ...              ...           ... ## 10042 Cluster_28...   957.771   20.2705               TG    TG 54:2;O3 ## 10043 Cluster_28...   960.791   20.8865           HexCer HexCer 52:... ## 10044 Cluster_28...   961.361   13.0214               NA            NA ## 10045 Cluster_28...   970.873   22.0981             ACer ACer 60:1;... ## 10046 Cluster_28...   972.734   15.6914          Hex2Cer Hex2Cer 42... ##       target_exactmass target_formula target_chain_type target_rtime ##              <numeric>    <character>       <character>    <numeric> ## 1                   NA             NA                NA           NA ## 2                   NA             NA                NA           NA ## 3                   NA             NA                NA           NA ## 4                   NA             NA                NA           NA ## 5                   NA             NA                NA           NA ## ...                ...            ...               ...          ... ## 10042          934.784      C57H106O9              even      15.9950 ## 10043          959.779     C58H105NO9              even      10.5076 ## 10044               NA             NA                NA           NA ## 10045          947.888     C60H117NO6              even       4.2806 ## 10046          971.727  C54H101NO1...              even      19.7329 ##            adduct      score ppm_error ##       <character>  <numeric> <numeric> ## 1              NA         NA        NA ## 2              NA         NA        NA ## 3              NA         NA        NA ## 4              NA         NA        NA ## 5              NA         NA        NA ## ...           ...        ...       ... ## 10042     [M+Na]+ -0.0021897  2.286241 ## 10043      [M+H]+  0.0045398  4.725089 ## 10044          NA         NA        NA ## 10045     [M+Na]+ -0.0045054  4.640545 ## 10046      [M+H]+ -0.0004240  0.435885 matched_sub <- matched_features[whichQuery(matched_features)] MetaboAnnotation::query(matched_sub) ## class: SummarizedExperiment  ## dim: 1969 4  ## metadata(0): ## assays(1): '' ## rownames: NULL ## rowData names(3): feature_id mz rtime ## colnames(4): A B C D ## colData names(0): library(QFeatures) ## Loading required package: MultiAssayExperiment ##  ## Attaching package: 'QFeatures' ## The following object is masked from 'package:base': ##  ##     sweep qf <- QFeatures(list(features = se)) qf ## An instance of class QFeatures (type: bulk) with 1 set: ##  ##  [1] features: SummarizedExperiment with 2842 rows and 4 columns matched_qf <- matchValues(qf, target_df, param = parm, queryAssay = \"features\") matched_qf ## Object of class Matched  ## Total number of matches: 9173  ## Number of query objects: 2842 (1969 matched) ## Number of target objects: 57599 (3296 matched) colnames(matched_qf) ##  [1] \"feature_id\"        \"mz\"                \"rtime\"             ##  [4] \"target_headgroup\"  \"target_name\"       \"target_exactmass\"  ##  [7] \"target_formula\"    \"target_chain_type\" \"target_rtime\"      ## [10] \"adduct\"            \"score\"             \"ppm_error\" matchedData(matched_qf) ## DataFrame with 10046 rows and 12 columns ##          feature_id        mz     rtime target_headgroup   target_name ##         <character> <numeric> <numeric>      <character>   <character> ## 1     Cluster_00...   102.128   1.56015               NA            NA ## 2     Cluster_00...   102.128   2.15359               NA            NA ## 3     Cluster_00...   102.128   2.92557               NA            NA ## 4     Cluster_00...   102.128   3.41962               NA            NA ## 5     Cluster_00...   102.127   5.80104               NA            NA ## ...             ...       ...       ...              ...           ... ## 10042 Cluster_28...   957.771   20.2705               TG    TG 54:2;O3 ## 10043 Cluster_28...   960.791   20.8865           HexCer HexCer 52:... ## 10044 Cluster_28...   961.361   13.0214               NA            NA ## 10045 Cluster_28...   970.873   22.0981             ACer ACer 60:1;... ## 10046 Cluster_28...   972.734   15.6914          Hex2Cer Hex2Cer 42... ##       target_exactmass target_formula target_chain_type target_rtime ##              <numeric>    <character>       <character>    <numeric> ## 1                   NA             NA                NA           NA ## 2                   NA             NA                NA           NA ## 3                   NA             NA                NA           NA ## 4                   NA             NA                NA           NA ## 5                   NA             NA                NA           NA ## ...                ...            ...               ...          ... ## 10042          934.784      C57H106O9              even      15.9950 ## 10043          959.779     C58H105NO9              even      10.5076 ## 10044               NA             NA                NA           NA ## 10045          947.888     C60H117NO6              even       4.2806 ## 10046          971.727  C54H101NO1...              even      19.7329 ##            adduct      score ppm_error ##       <character>  <numeric> <numeric> ## 1              NA         NA        NA ## 2              NA         NA        NA ## 3              NA         NA        NA ## 4              NA         NA        NA ## 5              NA         NA        NA ## ...           ...        ...       ... ## 10042     [M+Na]+ -0.0021897  2.286241 ## 10043      [M+H]+  0.0045398  4.725089 ## 10044          NA         NA        NA ## 10045     [M+Na]+ -0.0045054  4.640545 ## 10046      [M+H]+ -0.0004240  0.435885"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"matching-of-msms-spectra","dir":"Articles","previous_headings":"Example use cases","what":"Matching of MS/MS spectra","title":"Annotation of MS-based Metabolomics Data","text":"section match experimental MS/MS spectra reference spectra. can also performed functions Spectra package (see SpectraTutorials, functions concepts used suitable end user simplify handling spectra matching results. load spectra file reversed-phase (DDA) LC-MS/MS run Agilent Pesticide mix. filterMsLevel() subset data set MS2 spectra. reduce processing time example subset Spectra small set selected MS2 spectra. addition assign feature identifiers spectrum (, example arbitrary IDs, real data analysis identifiers indicate LC-MS feature spectra belong). Spectra now represent MS2 spectra associated LC-MS features untargeted LC-MS/MS experiment like annotate matching spectral reference library. thus load Spectra object represents MS2 data small subset MassBank release 2021.03. small Spectra object provided within package possible use Spectra object reference fragment spectra instead (see also SpectraTutorials workshop). alternative, also possible use CompDb object representing compound annotation database (defined CompoundDb package) parameter target. See matchSpectra() help page section Query multiple reference databases details options retrieve annotation resources Bioconductor’s AnnotationHub. can now use matchSpectra() function match experimental query spectra target (reference) spectra. Settings matching can defined dedicated param object. use CompareSpectraParam uses compareSpectra() function Spectra package calculate similarities query spectrum target spectra. CompareSpectraParam allows set individual settings compareSpectra() call parameters MAPFUN, ppm, tolerance FUN (see help compareSpectra() Spectra package details). addition, can pre-filter target spectra individual query spectrum speed-calculations. setting requirePrecursor = TRUE compare query spectrum target spectra matching precursor m/z (accepting deviation defined parameters ppm tolerance). default, matchSpectra() CompareSpectraParam considers spectra similarity score higher 0.7 matching thus reported. additional configuration set matchedPeaksCount = TRUE report number matching peaks compared (matched) spectra. results reported MatchedSpectra object represents matching results query spectra. type object contains query spectra, target spectra, matching information parameter object settings matching. object can subset results selected query spectra using [ method. length result object matches thus number query spectra: subset results first query spectrum: case, first query spectrum, match found among target spectra. subset MatchedSpectra results second query spectrum: second query spectrum matched 4 target spectra. matching query target spectra can n:m, .e. query spectrum can match multiple target spectra target spectrum can matched none, one multiple query spectra. Data (spectra variables either query /target spectra) can extracted result object spectraData() function $ (similar Spectra object). spectraVariables function can used list available spectra variables result object: lists spectra variables query target spectra, prefix \"target_\" used spectra variable names target spectra. Spectra variable \"score\" contains similarity score. matchedPeaksCount = TRUE used, column \"matched_peaks_count\" available lists number matching peaks compared spectra. Note default also additional column \".original_query_index\" added query Spectra object matchSpectra() function, enables easier mapping results original query object used input, particular, MatchedSpectra object gets subset. name says, column contains query spectrum index original Spectra object provided query parameter. thus use $target_compound_name extract compound name matching target spectra second query spectrum: information can also extracted full MatchedSpectra. use $spectrum_id extract query spectra identifiers added full result object. added column manually query object matchSpectra() call, automatically added spectra variable \".original_query_index\" provide information: respective values query object: n:m mapping query target spectra, number values returned $ (spectraData) can larger total number query spectra. Also example , spectra IDs present result returned $spectrum_id. respective spectra matched one target spectrum (based settings) hence IDs reported multiple times. spectraData $ MatchedSpectra use left join strategy report/return values: value (row) reported query spectrum (even match target spectrum) eventually duplicated values (rows) query spectrum matches one target spectrum (value query spectrum repeated many times matches target spectra). illustrate use spectraData() function extract specific data result object, .e. spectrum feature IDs query spectra defined , MS2 spectra similarity score, target spectra’s ID compound name. Using plotSpectraMirror() function can visualize matching results one query spectrum. Note also interactive, shiny-based, validation matching results available validateMatchedSpectra() function. call function show matches second spectrum.  unexpectedly, peak intensities query target spectra different scales. problem similarity calculation (normalized dot-product used default independent absolute peak values) ideal visualization. Thus, apply simple scaling function query target spectra plot spectra afterwards (see help addProcessing() Spectra package details spectra data manipulations). function replace absolute spectra intensities intensities relative maximum intensity spectrum. Note functions addProcessing() include (like example ) ... parameter.  query spectrum seems nicely match identified target spectra. extract compound name target spectra second query spectrum. alternative CompareSpectraParam also use MatchForwardReverseParam matchSpectra(). settings performs spectra similarity search CompareSpectraParam, reports addition (similar MS-DIAL) (forward) similarity score also reverse spectra similarity score well presence ratio matching spectra. default forward score calculated considering peaks query target spectrum (peak mapping performed using outer join strategy), reverse score calculated peaks present target spectrum matching peaks query spectrum (peak mapping performed using right join strategy). presence ratio ratio number mapped peaks query target spectrum total number peaks target spectrum. values available spectra variables \"reverse_score\" \"presence_ratio\" result object). perform spectra matching , using MatchForwardReverseParam. extract query target spectra IDs, compound name scores. examples matched query spectra target spectra precursor m/z ~ equal reported matches similarity higher 0.7. CompareSpectraParam, parameter THRESHFUN however also allow types analyses. example also report best matching target spectrum query spectrum, independently whether similarity score higher certain threshold. perform analysis defining THRESHFUN selects always best match. Note whole example work Spectra object MS2 spectra. objects also extracted xcms-based LC-MS/MS data analysis chromPeaksSpectra() featureSpectra() functions xcms package. Note also retention times addition considered matching selecting non-infinite value toleranceRt parameter classes. default uses retention times provided query target spectra (.e. spectra variable \"rtime\") also possible specify spectra variable additional retention time matching (e.g. retention indices instead times) using rtColname parameter matchSpectra(0 function (see ?matchSpectra help page information). Matches can also validated using interactive Shiny app calling validateMatchedSpectra() MatchedSpectra object. Individual matches can set TRUE FALSE app. closing app via Save & Close button filtered MatchedSpectra returned, containing matches manually validated.","code":"library(Spectra) library(msdata) fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L) ## subset to selected spectra. pest_ms2 <- pest_ms2[c(808, 809, 945:955)] ## assign arbitrary *feature IDs* to each spectrum. pest_ms2$feature_id <- c(\"FT001\", \"FT001\", \"FT002\", \"FT003\", \"FT003\", \"FT003\",                          \"FT004\", \"FT004\", \"FT004\", \"FT005\", \"FT005\", \"FT006\",                          \"FT006\") ## assign also *spectra IDs* to each pest_ms2$spectrum_id <- paste0(\"sp_\", seq_along(pest_ms2)) pest_ms2 ## MSn data (Spectra) with 13 spectra in a MsBackendMzR backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           2   361.651      2853 ## 2           2   361.741      2854 ## 3           2   377.609      3030 ## 4           2   377.699      3031 ## 5           2   378.120      3033 ## ...       ...       ...       ... ## 9           2   378.959      3039 ## 10          2   379.379      3041 ## 11          2   380.059      3045 ## 12          2   380.609      3048 ## 13          2   381.029      3050 ##  ... 36 more variables/columns. ##  ## file(s): ## PestMix1_DDA.mzML ## Processing: ##  Filter: select MS level(s) 2 [Thu May 29 13:53:43 2025] load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\")) minimb ## MSn data (Spectra) with 100 spectra in a MsBackendDataFrame backend: ##       msLevel     rtime scanIndex ##     <integer> <numeric> <integer> ## 1           2        NA        NA ## 2           2        NA        NA ## 3           2        NA        NA ## 4           2        NA        NA ## 5           2        NA        NA ## ...       ...       ...       ... ## 96         NA        NA        NA ## 97          2        NA        NA ## 98          2        NA        NA ## 99          2        NA        NA ## 100         2        NA        NA ##  ... 42 more variables/columns. ## Processing: ##  Filter: select spectra with polarity 1 [Wed Mar 31 10:06:28 2021] ##  Switch backend from MsBackendMassbankSql to MsBackendDataFrame [Wed Mar 31 10:07:59 2021] csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10,                            matchedPeaksCount = TRUE) mtches <- matchSpectra(pest_ms2, minimb, param = csp) mtches ## Object of class MatchedSpectra  ## Total number of matches: 16  ## Number of query objects: 13 (5 matched) ## Number of target objects: 100 (11 matched) length(pest_ms2) ## [1] 13 length(mtches) ## [1] 13 mtches[1] ## Object of class MatchedSpectra  ## Total number of matches: 0  ## Number of query objects: 1 (0 matched) ## Number of target objects: 100 (0 matched) mtches[2] ## Object of class MatchedSpectra  ## Total number of matches: 4  ## Number of query objects: 1 (1 matched) ## Number of target objects: 100 (4 matched) spectraVariables(mtches) ##  [1] \"msLevel\"                        \"rtime\"                          ##  [3] \"acquisitionNum\"                 \"scanIndex\"                      ##  [5] \"dataStorage\"                    \"dataOrigin\"                     ##  [7] \"centroided\"                     \"smoothed\"                       ##  [9] \"polarity\"                       \"precScanNum\"                    ## [11] \"precursorMz\"                    \"precursorIntensity\"             ## [13] \"precursorCharge\"                \"collisionEnergy\"                ## [15] \"isolationWindowLowerMz\"         \"isolationWindowTargetMz\"        ## [17] \"isolationWindowUpperMz\"         \"peaksCount\"                     ## [19] \"totIonCurrent\"                  \"basePeakMZ\"                     ## [21] \"basePeakIntensity\"              \"ionisationEnergy\"               ## [23] \"lowMZ\"                          \"highMZ\"                         ## [25] \"mergedScan\"                     \"mergedResultScanNum\"            ## [27] \"mergedResultStartScanNum\"       \"mergedResultEndScanNum\"         ## [29] \"injectionTime\"                  \"filterString\"                   ## [31] \"spectrumId\"                     \"ionMobilityDriftTime\"           ## [33] \"scanWindowLowerLimit\"           \"scanWindowUpperLimit\"           ## [35] \"electronBeamEnergy\"             \"feature_id\"                     ## [37] \"spectrum_id\"                    \".original_query_index\"          ## [39] \"target_msLevel\"                 \"target_rtime\"                   ## [41] \"target_acquisitionNum\"          \"target_scanIndex\"               ## [43] \"target_dataStorage\"             \"target_dataOrigin\"              ## [45] \"target_centroided\"              \"target_smoothed\"                ## [47] \"target_polarity\"                \"target_precScanNum\"             ## [49] \"target_precursorMz\"             \"target_precursorIntensity\"      ## [51] \"target_precursorCharge\"         \"target_collisionEnergy\"         ## [53] \"target_isolationWindowLowerMz\"  \"target_isolationWindowTargetMz\" ## [55] \"target_isolationWindowUpperMz\"  \"target_spectrum_id\"             ## [57] \"target_spectrum_name\"           \"target_date\"                    ## [59] \"target_authors\"                 \"target_license\"                 ## [61] \"target_copyright\"               \"target_publication\"             ## [63] \"target_splash\"                  \"target_compound_id\"             ## [65] \"target_adduct\"                  \"target_ionization\"              ## [67] \"target_ionization_voltage\"      \"target_fragmentation_mode\"      ## [69] \"target_collision_energy_text\"   \"target_instrument\"              ## [71] \"target_instrument_type\"         \"target_formula\"                 ## [73] \"target_exactmass\"               \"target_smiles\"                  ## [75] \"target_inchi\"                   \"target_inchikey\"                ## [77] \"target_cas\"                     \"target_pubchem\"                 ## [79] \"target_synonym\"                 \"target_precursor_mz_text\"       ## [81] \"target_compound_name\"           \"score\"                          ## [83] \"matched_peaks_count\" mtches[2]$target_compound_name ## [1] \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" mtches$spectrum_id ##  [1] \"sp_1\"  \"sp_2\"  \"sp_2\"  \"sp_2\"  \"sp_2\"  \"sp_3\"  \"sp_4\"  \"sp_4\"  \"sp_5\"  ## [10] \"sp_6\"  \"sp_6\"  \"sp_6\"  \"sp_7\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  \"sp_8\"  ## [19] \"sp_9\"  \"sp_9\"  \"sp_10\" \"sp_11\" \"sp_12\" \"sp_13\" mtches$.original_query_index ##  [1]  1  2  2  2  2  3  4  4  5  6  6  6  7  8  8  8  8  8  9  9 10 11 12 13 query(mtches)$.original_query_index ##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 mtches_df <- spectraData(mtches, columns = c(\"spectrum_id\", \"feature_id\",                                              \"score\", \"target_spectrum_id\",                                              \"target_compound_name\")) as.data.frame(mtches_df) ##    spectrum_id feature_id     score target_spectrum_id    target_compound_name ## 1         sp_1      FT001        NA               <NA>                    <NA> ## 2         sp_2      FT001 0.7869556           LU056604             Azaconazole ## 3         sp_2      FT001 0.8855473           LU056603             Azaconazole ## 4         sp_2      FT001 0.7234894           LU056602             Azaconazole ## 5         sp_2      FT001 0.7219942           LU056605             Azaconazole ## 6         sp_3      FT002        NA               <NA>                    <NA> ## 7         sp_4      FT003 0.7769746           KW108103 triphenylphosphineoxide ## 8         sp_4      FT003 0.7577286           KW108102 triphenylphosphineoxide ## 9         sp_5      FT003        NA               <NA>                    <NA> ## 10        sp_6      FT003 0.7433718           SM839501            Dimethachlor ## 11        sp_6      FT003 0.7019807           EA070705            Dimethachlor ## 12        sp_6      FT003 0.7081274           EA070711            Dimethachlor ## 13        sp_7      FT004        NA               <NA>                    <NA> ## 14        sp_8      FT004 0.7320465           SM839501            Dimethachlor ## 15        sp_8      FT004 0.8106258           EA070705            Dimethachlor ## 16        sp_8      FT004 0.7290458           EA070710            Dimethachlor ## 17        sp_8      FT004 0.8168876           EA070711            Dimethachlor ## 18        sp_8      FT004 0.7247800           EA070704            Dimethachlor ## 19        sp_9      FT004 0.7412586           KW108103 triphenylphosphineoxide ## 20        sp_9      FT004 0.7198787           KW108102 triphenylphosphineoxide ## 21       sp_10      FT005        NA               <NA>                    <NA> ## 22       sp_11      FT005        NA               <NA>                    <NA> ## 23       sp_12      FT006        NA               <NA>                    <NA> ## 24       sp_13      FT006        NA               <NA>                    <NA> plotSpectraMirror(mtches[2]) scale_int <- function(x, ...) {     x[, \"intensity\"] <- x[, \"intensity\"] / max(x[, \"intensity\"], na.rm = TRUE)     x } mtches <- addProcessing(mtches, scale_int) plotSpectraMirror(mtches[2]) mtches[2]$target_compound_name ## [1] \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" \"Azaconazole\" mp <- MatchForwardReverseParam(requirePrecursor = TRUE, ppm = 10) mtches <- matchSpectra(pest_ms2, minimb, param = mp) mtches ## Object of class MatchedSpectra  ## Total number of matches: 16  ## Number of query objects: 13 (5 matched) ## Number of target objects: 100 (11 matched) as.data.frame(     spectraData(mtches, c(\"spectrum_id\", \"target_spectrum_id\",                           \"target_compound_name\", \"score\", \"reverse_score\",                           \"presence_ratio\"))) ##    spectrum_id target_spectrum_id    target_compound_name     score ## 1         sp_1               <NA>                    <NA>        NA ## 2         sp_2           LU056604             Azaconazole 0.7869556 ## 3         sp_2           LU056603             Azaconazole 0.8855473 ## 4         sp_2           LU056602             Azaconazole 0.7234894 ## 5         sp_2           LU056605             Azaconazole 0.7219942 ## 6         sp_3               <NA>                    <NA>        NA ## 7         sp_4           KW108103 triphenylphosphineoxide 0.7769746 ## 8         sp_4           KW108102 triphenylphosphineoxide 0.7577286 ## 9         sp_5               <NA>                    <NA>        NA ## 10        sp_6           SM839501            Dimethachlor 0.7433718 ## 11        sp_6           EA070705            Dimethachlor 0.7019807 ## 12        sp_6           EA070711            Dimethachlor 0.7081274 ## 13        sp_7               <NA>                    <NA>        NA ## 14        sp_8           SM839501            Dimethachlor 0.7320465 ## 15        sp_8           EA070705            Dimethachlor 0.8106258 ## 16        sp_8           EA070710            Dimethachlor 0.7290458 ## 17        sp_8           EA070711            Dimethachlor 0.8168876 ## 18        sp_8           EA070704            Dimethachlor 0.7247800 ## 19        sp_9           KW108103 triphenylphosphineoxide 0.7412586 ## 20        sp_9           KW108102 triphenylphosphineoxide 0.7198787 ## 21       sp_10               <NA>                    <NA>        NA ## 22       sp_11               <NA>                    <NA>        NA ## 23       sp_12               <NA>                    <NA>        NA ## 24       sp_13               <NA>                    <NA>        NA ##    reverse_score presence_ratio ## 1             NA             NA ## 2      0.8764394      0.5833333 ## 3      0.9239592      0.6250000 ## 4      0.7573541      0.6250000 ## 5      0.9519647      0.4285714 ## 6             NA             NA ## 7      0.9025051      0.7500000 ## 8      0.9164348      0.5000000 ## 9             NA             NA ## 10     0.8915201      0.5000000 ## 11     0.8687003      0.3333333 ## 12     0.8687472      0.3703704 ## 13            NA             NA ## 14     0.8444402      0.5000000 ## 15     0.9267965      0.5000000 ## 16     0.8765496      0.7500000 ## 17     0.9236674      0.4814815 ## 18     0.8714208      0.8571429 ## 19     0.8743130      0.7500000 ## 20     0.8937751      0.5000000 ## 21            NA             NA ## 22            NA             NA ## 23            NA             NA ## 24            NA             NA select_top_match <- function(x) {     which.max(x) } csp2 <- CompareSpectraParam(ppm = 10, requirePrecursor = FALSE,                             THRESHFUN = select_top_match) mtches <- matchSpectra(pest_ms2, minimb, param = csp2) res <- spectraData(mtches, columns = c(\"spectrum_id\", \"target_spectrum_id\",                                        \"target_compound_name\", \"score\")) as.data.frame(res) ##    spectrum_id target_spectrum_id                   target_compound_name ## 1         sp_1           SM839603                             Flufenacet ## 2         sp_2           LU056603                            Azaconazole ## 3         sp_3           SM839501                           Dimethachlor ## 4         sp_4           KW108103                triphenylphosphineoxide ## 5         sp_5           LU100202        2,2'-(Tetradecylimino)diethanol ## 6         sp_6           SM839501                           Dimethachlor ## 7         sp_7           RP005503              Glycoursodeoxycholic acid ## 8         sp_8           EA070711                           Dimethachlor ## 9         sp_9           KW108103                triphenylphosphineoxide ## 10       sp_10           JP006901                  1-PHENYLETHYL ACETATE ## 11       sp_11           EA070711                           Dimethachlor ## 12       sp_12           EA070705                           Dimethachlor ## 13       sp_13           LU101704 2-Ethylhexyl 4-(dimethylamino)benzoate ##           score ## 1  0.000000e+00 ## 2  8.855473e-01 ## 3  6.313687e-01 ## 4  7.769746e-01 ## 5  1.772117e-05 ## 6  7.433718e-01 ## 7  1.906998e-03 ## 8  8.168876e-01 ## 9  7.412586e-01 ## 10 4.085289e-04 ## 11 4.323403e-01 ## 12 3.469648e-03 ## 13 7.612480e-06"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"query-against-multiple-reference-databases","dir":"Articles","previous_headings":"Example use cases > Matching of MS/MS spectra","what":"Query against multiple reference databases","title":"Annotation of MS-based Metabolomics Data","text":"Getting access reference spectra can sometimes little cumbersome since might involve lookup download specific resources eventual conversion format suitable import. MetaboAnnotation provides compound annotation sources simplify process. annotation source objects represent references (links) annotation resources can used matchSpectra() call define targed/reference spectra. annotation source object takes care, upon request, retrieving annotation data connecting annotation resources. Also, compound annotation sources can combined allow matching query spectra multiple reference libraries single call. present MetaboAnnotation supports following types compound annotation sources (.e. objects extending CompAnnotationSource): Annotation resources provide data CompDb database (defined CompoundDb) package. supported CompDbSource class. Annotation resources dedicated MsBackend backend available hence supporting access data via Spectra object. supported SpectraDbSource class. Various helper functions, specific annotation resource, available create annotation source objects: CompDbSource: creates compound annotation source object provided CompDb SQLite data base file. function can used integrate existing (locally available) CompDb annotation database annotation workflow. MassBankSource: creates annotation source object specific MassBank release. desired release can specified release parameter (e.g. release = \"2021.03\" release = \"2022.06\"). function download respective annotation database Bioconductor’s AnnotationHub. example create annotation source MassBank release 2022.06. call lookup requested version Biocondutor’s (online) AnnotationHub download data. Subsequent requests annotation resource load locally cached version instead. Upcoming MassBank database releases added AnnotationHub official release previous releases available well. can now use annotation source object matchSpectra() call compare experimental spectra previous examples release MassBank. result object contains matching fragment spectra reference database. names compounds matching fragment spectra.","code":"mbank <- MassBankSource(\"2022.06\") mbank ## Object of class CompDbSource  ## Metadata information: ##   - source: MassBank ##   - url: https://massbank.eu/MassBank/ ##   - source_version: 2022.06 ##   - source_date: 2022-06-21 ##   - organism: NA ##   - db_creation_date: Tue Aug 30 06:51:39 2022 ##   - supporting_package: CompoundDb ##   - supporting_object: CompDb res <- matchSpectra(     pest_ms2, mbank,     param = CompareSpectraParam(requirePrecursor = TRUE, ppm = 10)) ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. ## 'MsBackendCompDb' does not support parallel processing. Switching to serial processing. res ## Object of class MatchedSpectra  ## Total number of matches: 14  ## Number of query objects: 13 (6 matched) ## Number of target objects: 10 (10 matched) target(res) ## MSn data (Spectra) with 10 spectra in a MsBackendDataFrame backend: ##      msLevel     rtime scanIndex ##    <integer> <numeric> <integer> ## 1          2        NA        NA ## 2          2        NA        NA ## 3          2        NA        NA ## 4          2        NA        NA ## 5          2        NA        NA ## 6          2        NA        NA ## 7          2        NA        NA ## 8          2        NA        NA ## 9          2        NA        NA ## 10         2        NA        NA ##  ... 46 more variables/columns. ## Processing: ##  Switch backend from MsBackendCompDb to MsBackendDataFrame [Thu May 29 13:53:50 2025] matchedData(res)$target_name ##  [1] NA                         \"Azaconazole\"              ##  [3] \"Azaconazole\"              \"Azaconazole\"              ##  [5] \"Azaconazole\"              NA                         ##  [7] \"triphenylphosphineoxide\"  \"triphenylphosphineoxide\"  ##  [9] \"Triphenylphosphine oxide\" \"N,N-Dimethyldodecylamine\" ## [11] \"Dimethachlor\"             NA                         ## [13] \"Dimethachlor\"             \"Triphenylphosphine oxide\" ## [15] \"triphenylphosphineoxide\"  \"triphenylphosphineoxide\"  ## [17] \"Triphenylphosphine oxide\" NA                         ## [19] NA                         NA                         ## [21] NA"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"finding-ms2-spectra-for-selected-mz-and-retention-times","dir":"Articles","previous_headings":"Example use cases > Matching of MS/MS spectra","what":"Finding MS2 spectra for selected m/z and retention times","title":"Annotation of MS-based Metabolomics Data","text":"Sometimes needed identify fragment spectra Spectra object selected (precursor) m/z values retention times. example compound quantification performed LC-MS run second LC-MS/MS run (chromatographic setup) fragment spectra samples generated. first LC-MS data set features (chromatographic peaks) identified necessary retrieve fragment spectra matching m/z retention times second, LC-MS/MS data set (assuming big retention time shifts measurement runs expected). illustrate , first define data.frame represent feature table defined analysis xcms package. next match features data frame Spectra object using MzRtParam identify fragment spectra precursor m/z retention times matching (tolerance) values features. Thus, found fragment spectra matching m/z retention times 2nd 5th feature. extract Spectra matching features, best first reduce object features least one matching fragment spectrum. indices query elements (case features) matches can returned using whichQuery() function. use subset matched result keeping features matches found: feature IDs matched spectra can extracted using: next need extract matching fragment spectra target Spectra object. use targetIndex() function, returns indices target spectra matched query. extract thus next fragment spectra matching least one feature: now spectra, can’t relate (yet) features used query. Extracting \"feature_id\" column using $ function matched object however return, match (since restricted matched object contain features matches) feature ID (provided original data frame). can thus add information additional spectra variable Spectra object: aware extracting \"feature_id\" column matched object restricting features matches also return values features MS2 spectrum found: Without initial subsetting matched object features least one matching spectra, extraction bit complicated: Spectra next used match fragment spectra experiment e.g. reference database assigned spectra variable \"feature_id\" allow map results back quantified feature matrix LC-MS run.","code":"fts <- data.frame(     feature_id = c(\"FT001\", \"FT002\", \"FT003\", \"FT004\", \"FT005\"),     mzmed = c(313.43, 256.11, 224.08, 159.22, 224.08),     rtmed = c(38.5, 379.1, 168.2, 48.2, 381.1)) fts_mtch <- matchValues(fts, pest_ms2, MzRtParam(ppm = 50, toleranceRt = 3),                         mzColname = c(\"mzmed\", \"precursorMz\"),                         rtColname = c(\"rtmed\", \"rtime\")) fts_mtch ## Object of class Matched  ## Total number of matches: 5  ## Number of query objects: 5 (2 matched) ## Number of target objects: 13 (5 matched) whichQuery(fts_mtch) ## [1] 2 5 fts_mtched <- fts_mtch[whichQuery(fts_mtch)] fts_mtched ## Object of class Matched  ## Total number of matches: 5  ## Number of query objects: 2 (2 matched) ## Number of target objects: 13 (5 matched) fts_mtched$feature_id ## [1] \"FT002\" \"FT002\" \"FT002\" \"FT005\" \"FT005\" targetIndex(fts_mtched) ## [1]  3  6  8  7 11 fts_ms2 <- target(fts_mtched)[targetIndex(fts_mtched)] fts_ms2 ## MSn data (Spectra) with 5 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         2   377.609      3030 ## 2         2   378.539      3035 ## 3         2   378.869      3038 ## 4         2   378.779      3037 ## 5         2   380.059      3045 ##  ... 36 more variables/columns. ##  ## file(s): ## PestMix1_DDA.mzML ## Processing: ##  Filter: select MS level(s) 2 [Thu May 29 13:53:43 2025] fts_ms2$feature_id <- fts_mtched$feature_id fts_mtch$feature_id ## [1] \"FT001\" \"FT002\" \"FT002\" \"FT002\" \"FT003\" \"FT004\" \"FT005\" \"FT005\" fts_ms2 <- target(fts_mtch)[targetIndex(fts_mtch)] fts_ms2$feature_id <- query(fts_mtch)$feature_id[queryIndex(fts_mtch)] fts_ms2$feature_id ## [1] \"FT002\" \"FT002\" \"FT002\" \"FT005\" \"FT005\""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"performance-and-parallel-processing","dir":"Articles","previous_headings":"Example use cases > Matching of MS/MS spectra","what":"Performance and parallel processing","title":"Annotation of MS-based Metabolomics Data","text":"Pre-filtering target spectra based similar precursor m/z (using requirePrecursor = TRUE generally speeds call spectra comparison needs performed subsets target spectra. Performance matchSpectra() function depends however also backend used query target Spectra. backends peaks data (.e. m/z intensity values) might already loaded memory hence spectra comparisons might slower data needs first loaded. example, Spectra objects, pest_ms2 variable, use MsBackendMzRbackend, peaks data needs loaded raw data files spectra similarity scores can calculated. Changing backend -memory data representation matchSpectra() can thus improve performance (cost higher memory demand). change backends pest_ms2 minimb objects MsBackendMemory keeps data (spectra peaks data) memory compare performance originally used MsBackendMzR (pest_ms2) MsBackendDataFrame (minimb). considerable performance gain using MsBackendMemory two backends, comes however cost higher memory demand. Thus, large data sets (reference libraries) might option. See also issue #93 MetaboAnnotation github repository benchmarks information performance matchSpectra(). target Spectra using SQL database-based backend used (MsBackendMassbankSql, MsBackendCompDb MsBackendSql) spectra matching performed requirePrecursorMz = TRUE, simply caching precursor m/z values target spectra memory improves performance matchSpectra considerably. can easily done e.g. target_sps$precursorMz <- precursorMz(target_sps) target_sps Spectra object uses one mentioned backends. call precursor m/z values cached within target_sps precursorMz(target_sps) call (used matchSpectra() select candidate spectra compare query spectrum) require separate SQL call. Parallel processing can also improve performance, might possible backends. particular, backends based SQL databases don’t allow parallel processing database connection can shared across different processes.","code":"pest_ms2_mem <- setBackend(pest_ms2, MsBackendMemory()) minimb_mem <- setBackend(minimb, MsBackendMemory()) library(microbenchmark) microbenchmark(compareSpectra(pest_ms2, minimb, param = csp),                compareSpectra(pest_ms2_mem, minimb_mem, param = csp),                times = 5) ## Unit: milliseconds ##                                                   expr      min       lq ##          compareSpectra(pest_ms2, minimb, param = csp) 48.41246 48.63199 ##  compareSpectra(pest_ms2_mem, minimb_mem, param = csp) 28.39517 28.51699 ##      mean   median       uq      max neval ##  56.43959 49.42993 49.61194 86.11163     5 ##  31.58886 28.75317 29.61067 42.66829     5"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"utility-functions","dir":"Articles","previous_headings":"","what":"Utility functions","title":"Annotation of MS-based Metabolomics Data","text":"MetaboAnnotation provides also utility functions directly related annotation process. presented section.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"creating-mixes-of-standard-compounds","dir":"Articles","previous_headings":"Utility functions","what":"Creating mixes of standard compounds","title":"Annotation of MS-based Metabolomics Data","text":"function createStandardMixes() allows grouping standard compounds minimum difference m/z based user input.","code":"library(MetaboCoreUtils)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"input-format","dir":"Articles","previous_headings":"Utility functions > Creating mixes of standard compounds","what":"Input format","title":"Annotation of MS-based Metabolomics Data","text":"example extract list 100 standard compounds formula tab delimited text file provided package. files also imported xlsx sheet using readxl package. use functions MetaboCoreUtil package get mass compounds m/z adducts wanted. input table createStandardMixes thus look like one shown , .e. numeric matrix row representing one compound. Columns expected contain m/z values different adducts compound. Importantly, row names matrix represent (unique) compound names (unique identifier compound).","code":"standard <- read.table(system.file(\"extdata\", \"Standard_list_example.txt\",                                package = \"MetaboAnnotation\"),                    header = TRUE, sep = \"\\t\", quote = \"\") #' Calculate mass based on formula of compounds standard$mass <- calculateMass(standard$formula)  #' Create input for function #' Calculate charge for 2 adducts standard_charged <- mass2mz(standard$mass, adduct = c(\"[M+H]+\", \"[M+Na]+\"))  #' have compounds names as rownames rownames(standard_charged) <- standard[ , 1]  #' ensure the input `x` is a matrix if (!is.matrix(standard_charged))     standard_charged <- as.matrix(standard_charged) standard_charged ##                                                         [M+H]+   [M+Na]+ ## 2-Acetylpyrazine                                     123.05529 145.03723 ## Guanosine 5′-diphosphate sodium sa                   444.03161 466.01355 ## Quinoline-4-carboxylic acid                          174.05495 196.03690 ## Heneicosanoic acid                                   327.32576 349.30770 ## Sudan III                                            353.13969 375.12163 ## Erythrosine B                                        836.66234 858.64429 ## Hypoxanthine                                         137.04579 159.02773 ## 2-Oxoadipic acid                                     161.04445 183.02639 ## N-Acetyl-L-cysteine                                  164.03759 186.01953 ## Carbamazepine                                        237.10224 259.08418 ## Famotidine                                           338.05221 360.03416 ## \"trans-2-Butene-1,4-dicarboxylic acid\"               145.04953 167.03148 ## DL-p-Hydroxyphenyllactic acid                        183.06518 205.04713 ## \"Malachite Green, Oxalate\"                           365.17790 387.15985 ## Brucine sulfate heptahydrate                         395.19653 417.17848 ## Uric acid                                            169.03562 191.01756 ## Glycocholic acid hydrate                             466.31631 488.29826 ## DL-4-Hydroxy-3-methoxymandelic acid                  199.06010 221.04204 ## Phosphorylcholine chloride calcium salt tetrahydrate 185.08115 207.06309 ## Imidazole                                             69.04472  91.02667 ## Indole                                               118.06513 140.04707 ## Perindopril erbumine                                 369.23840 391.22034 ## Folinic acid calcium salt hydrate                    474.17317 496.15512 ## \"Tauroursodeoxycholic acid, Na salt\"                 500.30404 522.28598 ## Glycyl-L-leucine                                     189.12337 211.10531 ## Carotene                                             537.44548 559.42742 ## 2-Methylsuccinic acid                                133.04953 155.03148 ## DL-m-Tyrosine                                        182.08117 204.06311 ## Ursodeoxycholic acid                                 393.29994 415.28188 ## N-Acetyl-L-alanine                                   132.06552 154.04746 ## 3-Hydroxybenzyl alcohol                              125.05971 147.04165 ## 2-Hydroxy-4-(methylthio)butyric acid calcium salt    151.04234 173.02429 ## Myrcene                                              137.13248 159.11442 ## \"3,4-Dihydroxybenzeneacetic acid\"                    169.04953 191.03148 ## Deoxycholic acid                                     393.29994 415.28188 ## 2-Aminobenzenesulfonic acid                          174.02194 196.00388 ## Indole-3-acetamide                                   175.08659 197.06853 ## L-Glutathione reduced                                308.09108 330.07303 ## (±)-3-Methyl-2-oxovaleric acid sodium sal            131.07027 153.05221 ## Lithocholic acid                                     377.30502 399.28697 ## Chenodeoxycholic acid sodium salt                    393.29994 415.28188 ## D-Allose                                             181.07066 203.05261 ## Solvent Blue 35                                      351.20670 373.18865 ## Tetradecanedioic acid                                259.19039 281.17233 ## Food Yellow 3                                        409.01587 430.99781 ## L-Homocitrulline                                     190.11862 212.10056 ## 3-Methylxanthine                                     167.05635 189.03830 ## Acid Yellow 36                                       354.09069 376.07263 ## L-Arabitol                                           153.07575 175.05769 ## Sodium phytate hydrate                               660.86865 682.85059 ## Phosphoserine                                        186.01620 207.99814 ## Deoxy-D-glucose                                      165.07575 187.05769 ## Alanine methyl ester hydrochloride                   104.07060 126.05255 ## Phenylac-Gly-OH                                      194.08117 216.06311 ## NADPH sodium salt                                    746.09838 768.08032 ## Pyridoxine HCl                                       170.08117 192.06311 ## L-Malic ac                                           135.02880 157.01074 ## Uracil                                               113.03455 135.01650 ## Adenosine                                            268.10403 290.08597 ## L-Carnitine inner salt                               162.11247 184.09441 ## Acetyl-L-glutamin                                    189.08698 211.06893 ## Aminobutyric acid                                    104.07060 126.05255 ## Ortho-Hydroxyphenylacetic acid                       153.05462 175.03656 ## Riboflavin                                           377.14556 399.12750 ## Diaminobutane dihydrochloride                         89.10732 111.08927 ## Sarcosine                                             90.05495 112.03690 ## L-Carnosine                                          227.11387 249.09581 ## Methylmalonic acid                                   119.03388 141.01583 ## L-Pyroglutamic acid                                  130.04987 152.03181 ## Rhodamine B                                          444.24074 466.22269 ## Indigo Carmine                                       422.99513 444.97708 ## Diaminopropionic acid monohydrochloride              105.06585 127.04780 ## Dimethylbenzimidazole                                147.09167 169.07362 ## N-Acetyl-L-aspartic acid                             176.05535 198.03729 ## Thiamine hydrochloride hydrate                       266.11958 288.10153 ## Taurine                                              126.02194 148.00388 ## Maleic acid                                          117.01823 139.00018 ## O-Acetyl-L-carnitine HCl                             204.12303 226.10498 ## N-Acetyl-D-galactosamine                             222.09721 244.07916 ## Citric acid                                          193.03428 215.01622 ## Dimethylglycine hydrochloride                        104.07060 126.05255 ## Erioglaucine disodium salt                           750.17339 772.15534 ## Sebacic acid                                         203.12779 225.10973 ## Stearic acid                                         285.27881 307.26075 ## L-Arginine                                           175.11895 197.10090 ## 2'-Deoxyuridine                                      229.08190 251.06384 ## Maltotriose                                          505.17631 527.15825 ## dimethyl-L-Valine                                    146.11755 168.09950 ## Acetylphenothiazine                                  242.06341 264.04535 ## Methoxybenzoic acid                                  153.05462 175.03656 ## Metyrosine                                           196.09682 218.07876 ## Rhein                                                285.03936 307.02131 ## N6-Methyladenine                                     150.07742 172.05937 ## Hydroxybenzoic acid                                  139.03897 161.02091 ## Sodium D-gluconate                                   197.06558 219.04752 ## L-Threonic acid Calcium Salt                         137.04445 159.02639 ## Methyl 3-aminopyrazine-2-carboxylate                 154.06110 176.04305 ## DL-α-Lipoamid                                        206.06678 228.04873 ## Lauric acid                                          201.18491 223.16685 ## Nicotinamide mononucleotide                          336.07170 358.05365"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"using-the-function","dir":"Articles","previous_headings":"Utility functions > Creating mixes of standard compounds","what":"Using the function","title":"Annotation of MS-based Metabolomics Data","text":"createStandardMixes() function organizes given compounds way compound placed group ions (adducts) m/z difference exceeding user-defined threshold (default: min_diff = 2). initial example, aim group subset compound list execute function default parameters: Let’s see number compounds per group: grouping worked perfectly, let’s now use entire compound list run default parameter : time can see grouping less ideal. case can switch iterativeRandomization = TRUE. Changing iterativeRandomization = default FALSE TRUE enables randomization input x rows fits min_nstd parameter. list compounds long requirement hard fit, function can take bit longer iterativeRandomization = set TRUE. want groups maximum 20 minimum 15 compounds, minimum difference 2 m/z compounds group? want know parameters function, look ?createStandardMixes. Great ! groups look good; can now export. function already returns data.frame, can directly save Excel file using write_xlsx() writexl R package text format can also open Excel.","code":"group_no_randomization <- createStandardMixes(standard_charged[1:20,]) group_no_randomization ##                                                         [M+H]+   [M+Na]+ group ## 2-Acetylpyrazine                                     123.05529 145.03723     1 ## Guanosine 5′-diphosphate sodium sa                   444.03161 466.01355     1 ## Quinoline-4-carboxylic acid                          174.05495 196.03690     1 ## Heneicosanoic acid                                   327.32576 349.30770     1 ## Sudan III                                            353.13969 375.12163     1 ## Erythrosine B                                        836.66234 858.64429     1 ## Hypoxanthine                                         137.04579 159.02773     1 ## 2-Oxoadipic acid                                     161.04445 183.02639     1 ## N-Acetyl-L-cysteine                                  164.03759 186.01953     1 ## Carbamazepine                                        237.10224 259.08418     1 ## Famotidine                                           338.05221 360.03416     2 ## \"trans-2-Butene-1,4-dicarboxylic acid\"               145.04953 167.03148     2 ## DL-p-Hydroxyphenyllactic acid                        183.06518 205.04713     2 ## \"Malachite Green, Oxalate\"                           365.17790 387.15985     2 ## Brucine sulfate heptahydrate                         395.19653 417.17848     2 ## Uric acid                                            169.03562 191.01756     2 ## Glycocholic acid hydrate                             466.31631 488.29826     2 ## DL-4-Hydroxy-3-methoxymandelic acid                  199.06010 221.04204     2 ## Phosphorylcholine chloride calcium salt tetrahydrate 185.08115 207.06309     2 ## Imidazole                                             69.04472  91.02667     2 table(group_no_randomization$group) ##  ##  1  2  ## 10 10 group_no_randomization <- createStandardMixes(standard_charged) table(group_no_randomization$group) ##  ##  1  2  3  4  5  6  7  8  9 10 11  ## 10 10 10 10 10 10 10 10 10  7  3 group_with_ramdomization <- createStandardMixes(standard_charged,                                                 iterativeRandomization = TRUE)  table(group_with_ramdomization$group) ##  ##  1  2  3  4  5  6  7  8  9 10  ## 10 10 10 10 10 10 10 10 10 10 set.seed(123) group_with_ramdomization <- createStandardMixes(standard_charged,                                                 max_nstd = 15,                                                 min_nstd = 10,                                                 min_diff = 2,                                                 iterativeRandomization = TRUE)  table(group_with_ramdomization$group) ##  ##  1  2  3  4  5  6  7  ## 15 15 15 15 15 15 10 write.table(group_with_ramdomization,            file = \"standard_mixes.txt\", sep = \"\\t\", quote = FALSE)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Annotation of MS-based Metabolomics Data","text":"","code":"## R version 4.5.0 (2025-04-11) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] MetaboCoreUtils_1.17.1      microbenchmark_1.5.0        ##  [3] msdata_0.49.0               QFeatures_1.19.2            ##  [5] MultiAssayExperiment_1.35.3 SummarizedExperiment_1.39.0 ##  [7] Biobase_2.69.0              GenomicRanges_1.61.0        ##  [9] GenomeInfoDb_1.45.3         IRanges_2.43.0              ## [11] MatrixGenerics_1.21.0       matrixStats_1.5.0           ## [13] Spectra_1.19.2              BiocParallel_1.43.2         ## [15] S4Vectors_0.47.0            MetaboAnnotation_1.13.1     ## [17] AnnotationHub_3.99.5        BiocFileCache_2.99.5        ## [19] dbplyr_2.5.0                BiocGenerics_0.55.0         ## [21] generics_0.1.4              BiocStyle_2.37.0            ##  ## loaded via a namespace (and not attached): ##  [1] DBI_1.2.3               bitops_1.0-9            gridExtra_2.3           ##  [4] httr2_1.1.2             rlang_1.1.6             magrittr_2.0.3          ##  [7] clue_0.3-66             compiler_4.5.0          RSQLite_2.3.11          ## [10] reshape2_1.4.4          png_0.1-8               systemfonts_1.2.3       ## [13] vctrs_0.6.5             stringr_1.5.1           ProtGenerics_1.41.0     ## [16] pkgconfig_2.0.3         crayon_1.5.3            fastmap_1.2.0           ## [19] XVector_0.49.0          rmarkdown_2.29          UCSC.utils_1.5.0        ## [22] ragg_1.4.0              purrr_1.0.4             bit_4.6.0               ## [25] xfun_0.52               cachem_1.1.0            ChemmineR_3.61.0        ## [28] jsonlite_2.0.0          blob_1.2.4              DelayedArray_0.35.1     ## [31] parallel_4.5.0          cluster_2.1.8.1         R6_2.6.1                ## [34] bslib_0.9.0             stringi_1.8.7           RColorBrewer_1.1-3      ## [37] jquerylib_0.1.4         Rcpp_1.0.14             bookdown_0.43           ## [40] knitr_1.50              base64enc_0.1-3         BiocBaseUtils_1.11.0    ## [43] igraph_2.1.4            Matrix_1.7-3            tidyselect_1.2.1        ## [46] abind_1.4-8             yaml_2.3.10             codetools_0.2-20        ## [49] curl_6.2.3              plyr_1.8.9              lattice_0.22-7          ## [52] tibble_3.2.1            withr_3.0.2             KEGGREST_1.49.0         ## [55] evaluate_1.0.3          desc_1.4.3              xml2_1.3.8              ## [58] Biostrings_2.77.1       pillar_1.10.2           BiocManager_1.30.25     ## [61] filelock_1.0.3          DT_0.33                 ncdf4_1.24              ## [64] RCurl_1.98-1.17         BiocVersion_3.22.0      ggplot2_3.5.2           ## [67] scales_1.4.0            glue_1.8.0              lazyeval_0.2.2          ## [70] tools_4.5.0             mzR_2.43.0              fs_1.6.6                ## [73] grid_4.5.0              tidyr_1.3.1             MsCoreUtils_1.21.0      ## [76] AnnotationDbi_1.71.0    cli_3.6.5               rappdirs_0.3.3          ## [79] textshaping_1.0.1       rsvg_2.6.2              S4Arrays_1.9.0          ## [82] dplyr_1.1.4             AnnotationFilter_1.33.0 gtable_0.3.6            ## [85] sass_0.4.10             digest_0.6.37           SparseArray_1.9.0       ## [88] rjson_0.2.23            htmlwidgets_1.6.4       farver_2.1.2            ## [91] memoise_2.0.1           htmltools_0.5.8.1       pkgdown_2.1.3.9000      ## [94] lifecycle_1.0.4         httr_1.4.7              CompoundDb_1.13.0       ## [97] bit64_4.6.0-1           MASS_7.3-65"},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Witting. Author. Johannes Rainer. Author, maintainer. Andrea Vicini. Author. Carolin Huber. Author. Philippine Louail. Author. Nir Shachaf. Contributor.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J, Vicini , Salzer L, Stanstrup J, Badia JM, Neumann S, Stravs MA, Verri Hernandes V, Gatto L, Gibb S Wittin M. Modular Expandable Ecosystem Metabolomics Data Annotation R Metabolites 2022, 12, 173. https://doi.org/10.3390/metabo12020173","code":"@Article{,   title = {A Modular and Expandable Ecosystem for Metabolomics Data Annotation in R},   author = {Johannes Rainer and Andrea Vicini and Liesa Salzer and Jan Stanstrup and Josep M. Badia and Steffen Neumann and Michael A. Stravs and Vinicius {Verri Hernandes} and Laurent Gatto and Sebastian Gibb and Michael Witting},   journal = {Metabolites},   year = {2022},   doi = {10.3390/metabo12020173},   url = {https://www.mdpi.com/2218-1989/12/2/173},   volume = {12},   pages = {173}, }"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"metaboannotation","dir":"","previous_headings":"","what":"Utilities for Annotation of Metabolomics Data","title":"Utilities for Annotation of Metabolomics Data","text":"High level functions assist annotation (metabolomics) data sets. include functions perform simple tentative annotations based mass matching also functions consider m/z retention times annotation LC-MS features given respective reference values available. addition, function provides high-level functions simplify matching LC-MS/MS spectra spectral libraries objects functionality represent manage matched data. information see package homepage.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Utilities for Annotation of Metabolomics Data","text":"package can installed ","code":"install.packages(\"BiocManager\") BiocManager::install(\"MetaboAnnotation\")"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Utilities for Annotation of Metabolomics Data","text":"Contributions highly welcome follow contribution guidelines. Also, please check coding style guidelines RforMassSpectrometry vignette.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompAnnotationSource.html","id":null,"dir":"Reference","previous_headings":"","what":"Compound Annotation Sources — CompAnnotationSource","title":"Compound Annotation Sources — CompAnnotationSource","text":"CompAnnotationSources (.e. classes extending base virtual CompAnnotationSource class) define provide access (potentially remote) compound annotation resource. aims simplify integration external annotation resources automating actual connection (data resource download) process user. addition, since reference resource directly exposed user allows integration annotation resources allow access full data. Objects extending CompAnnotationSource available package : CompDbSource(): annotation source referencing annotation source [CompoundDb::CompDb()] format ( CompoundDb Bioconductor package). Classes extending CompAnnotationSource need implement matchSpectra method parameters query, target param query Spectra object (experimental) query spectra, target object extending CompAnnotationSource param parameter object defining similarity calculation (e.g. CompareSpectraParam(). method expected return MatchedSpectra object. CompAnnotationSource objects expected contain annotation data. Access annotation data (form Spectra object) suggested established within object's matchSpectra method. also enable parallel processing annotations e.g. database connection shared across processes.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompAnnotationSource.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compound Annotation Sources — CompAnnotationSource","text":"","code":"# S4 method for class 'Spectra,CompAnnotationSource,Param' matchSpectra(query, target, param, ...)  # S4 method for class 'CompAnnotationSource' show(object)  # S4 method for class 'CompAnnotationSource' metadata(x, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompAnnotationSource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compound Annotation Sources — CompAnnotationSource","text":"query matchSpectra: Spectra::Spectra object query spectra. target matchSpectra: object extending CompAnnotationSource (CompDbSource) target (reference) spectra compare query . param matchSpectra: parameter object (CompareSpectraParam) defining settings matching. ... additional parameters passed matchSpectra. object CompAnnotationSource object. x CompAnnotationSource object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompAnnotationSource.html","id":"methods-that-need-to-be-implemented","dir":"Reference","previous_headings":"","what":"Methods that need to be implemented","title":"Compound Annotation Sources — CompAnnotationSource","text":"example implementation see CompDbSource(). matchSpectra: function match experimental MS2 spectra annotation source. See matchSpectra() parameters. metadata: function provide metadata annotation resource (host, source, version etc). show (optional): method provide general information data source.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompAnnotationSource.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compound Annotation Sources — CompAnnotationSource","text":"Johannes Rainer, Nir Shachaf","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompDbSource.html","id":null,"dir":"Reference","previous_headings":"","what":"Compound Annotation Sources for CompDb databases — CompDbSource","title":"Compound Annotation Sources for CompDb databases — CompDbSource","text":"CompDbSource objects represent references CompoundDb::CompDb database-backed annotation resources. Instances expected created dedicated construction functions MassBankSource generic CompDbSource. annotation data stored within object accessed/loaded within object's matchSpectra method. New CompDbSource objects can created using functions: CompDbSource: create new CompDbSource object existing CompDb database. (SQLite) database file (including full path) needs provided parameter dbfile. MassBankSource: retrieves CompDb database specified MassBank release Bioconductor's online AnnotationHub (exists) uses . Note AnnotationHub resources cached locally thus downloaded first time. function parameters release allows define desired MassBank release (e.g. release = \"2021.03\" release = \"2022.06\") ... allows pass optional parameters AnnotationHub constructor function, localHub = TRUE use cached data avoid updating/retrieving updates internet. functions: metadata: get metadata (information) annotation resource.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompDbSource.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compound Annotation Sources for CompDb databases — CompDbSource","text":"","code":"CompDbSource(dbfile = character())  # S4 method for class 'CompDbSource' metadata(x, ...)  # S4 method for class 'CompDbSource' show(object)  MassBankSource(release = \"2021.03\", ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompDbSource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compound Annotation Sources for CompDb databases — CompDbSource","text":"dbfile character(1) database file (including full path). x CompDbSource object. ... CompDbSource: ignored. MassBankSource: optional parameters passed AnnotationHub constructor function. object CompDbSource object. release character(1) defining version/release MassBank used.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompDbSource.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compound Annotation Sources for CompDb databases — CompDbSource","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompDbSource.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compound Annotation Sources for CompDb databases — CompDbSource","text":"","code":"## Locate a CompDb SQLite database file. For this example we use the test ## database from the `CompoundDb` package. fl <- system.file(\"sql\", \"CompDb.MassBank.sql\", package = \"CompoundDb\") ann_src <- CompDbSource(fl)  ## The object contains only the reference/link to the annotation resource. ann_src #> Object of class CompDbSource  #> Metadata information: #>   - source: MassBank #>   - url: https://massbank.eu/MassBank/ #>   - source_version: 2020.09 #>   - source_date: 1603272565 #>   - organism: NA #>   - db_creation_date: Thu Oct 22 08:45:31 2020 #>   - supporting_package: CompoundDb #>   - supporting_object: CompDb  ## Retrieve a CompDb with MassBank data for a certain MassBank release mb_src <- MassBankSource(\"2021.03\") mb_src #> Object of class CompDbSource  #> Metadata information: #>   - source: MassBank #>   - url: https://massbank.eu/MassBank/ #>   - source_version: 2021.03 #>   - source_date: 2021-02-26 #>   - organism: NA #>   - db_creation_date: Tue Aug 30 06:53:53 2022 #>   - supporting_package: CompoundDb #>   - supporting_object: CompDb"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","title":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","text":"matchSpectra compares experimental (query) MS2 spectra reference (target) MS2 spectra reports matches similarity passing specified threshold. function performs similarity calculation query spectrum target spectrum. Parameters query target can used define query target spectra, respectively, parameter param allows define configure similarity calculation matching condition. Parameter query takes Spectra::Spectra object target can either Spectra::Spectra object, CompoundDb::CompDb (reference library) object defined CompoundDb package CompAnnotationSource (e.g. CompDbSource()) reference connection information supported annotation resource). notes performance information parallel processing provided vignette. Currently supported parameter objects defining matching : CompareSpectraParam: generic parameter object allowing set settings Spectra::compareSpectra() call used perform similarity calculation. includes MAPFUN FUN defining peak-mapping similarity calculation functions ppm tolerance define acceptable difference m/z values compared peaks. Parameter matchedPeaksCount also passed compareSpectra() , set TRUE (default FALSE) report number peaks defined matching MAPFUN. Additional parameters compareSpectra call can passed along .... See help Spectra::Spectra() information parameters. Parameters requirePrecursor (default TRUE) requirePrecursorPeak (default FALSE) allow pre-filter target spectra prior actual similarity calculation individual query spectrum. Target spectra can also pre-filtered based retention time parameter toleranceRt set value different default toleranceRt = Inf. target spectra retention time within query's retention time +/- (toleranceRt + percentRt% query's retention time) considered. Note ppm tolerance single value accepted, toleranceRt percentRt can also length equal number query spectra hence allowing define different rt boundaries query spectrum. pre-filters can considerably improve performance, noted matches found query target spectra missing values considered variable (precursor m/z retention time). target spectra without retention times (Spectra public reference database MassBank) default toleranceRt = Inf thus used. Finally, parameter THRESHFUN allows define function applied similarity scores define matches report. See details. MatchForwardReverseParam: performs spectra matching CompareSpectraParam reports, similar MS-DIAL, also reverse similarity score presence ratio. detail, matching query spectra target spectra performed considering peaks query peaks target (reference) spectrum (.e. forward matching using outer join-based peak matching strategy). matching spectra also reverse similarity calculated considering peaks present target (reference) spectrum (.e. using right join-based peak matching). reported spectra variable \"reverse_score\". addition, ratio number matched peaks total number peaks target (reference) spectra reported presence ratio (spectra variable \"presence_ratio\") total number matched peaks \"matched_peaks_count\". See examples details. Parameter THRESHFUN_REVERSE allows define additional threshold function filter matches. THRESHFUN_REVERSE defined matches spectra similarity fulfilling THRESHFUN THRESHFUN_REVERSE returned. default THRESHFUN_REVERSE = NULL matches passing THRESHFUN reported.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","text":"","code":"# S4 method for class 'Spectra,CompDbSource,Param' matchSpectra(   query,   target,   param,   BPPARAM = BiocParallel::SerialParam(),   addOriginalQueryIndex = TRUE )  CompareSpectraParam(   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 5,   FUN = MsCoreUtils::ndotproduct,   requirePrecursor = TRUE,   requirePrecursorPeak = FALSE,   THRESHFUN = function(x) which(x >= 0.7),   toleranceRt = Inf,   percentRt = 0,   matchedPeaksCount = FALSE,   ... )  MatchForwardReverseParam(   MAPFUN = joinPeaks,   tolerance = 0,   ppm = 5,   FUN = MsCoreUtils::ndotproduct,   requirePrecursor = TRUE,   requirePrecursorPeak = FALSE,   THRESHFUN = function(x) which(x >= 0.7),   THRESHFUN_REVERSE = NULL,   toleranceRt = Inf,   percentRt = 0,   ... )  # S4 method for class 'Spectra,Spectra,CompareSpectraParam' matchSpectra(   query,   target,   param,   rtColname = c(\"rtime\", \"rtime\"),   BPPARAM = BiocParallel::SerialParam(),   addOriginalQueryIndex = TRUE )  # S4 method for class 'Spectra,CompDb,Param' matchSpectra(   query,   target,   param,   rtColname = c(\"rtime\", \"rtime\"),   BPPARAM = BiocParallel::SerialParam(),   addOriginalQueryIndex = TRUE )  # S4 method for class 'Spectra,Spectra,MatchForwardReverseParam' matchSpectra(   query,   target,   param,   rtColname = c(\"rtime\", \"rtime\"),   BPPARAM = BiocParallel::SerialParam(),   addOriginalQueryIndex = TRUE )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","text":"query matchSpectra: Spectra::Spectra object query spectra. target matchSpectra: Spectra::Spectra, CompoundDb::CompDb object extending CompAnnotationSource (CompDbSource) target (reference) spectra compare query . param matchSpectra: parameter object (CompareSpectraParam) defining settings matching. BPPARAM matchSpectra: parallel processing setup (see BiocParallel package information). Parallel processing disabled default (default setting BPPARAM = SerialParam()). addOriginalQueryIndex matchSpectra(): logical(1) whether additional spectra variable \".original_query_index\" added query Spectra object providing index spectrum originally provided object. spectra variable can useful link back original Spectra object MatchedSpectra object gets subsetted/processed. MAPFUN function used map peaks compared spectra. Defaults CompareSpectraParam Spectra::joinPeaks(). See Spectra::compareSpectra() details. tolerance numeric(1) absolute maximal accepted difference m/z values. used compareSpectra well eventual precursor m/z matching. ppm numeric(1) relative, m/z-dependent, maximal accepted difference m/z values. used compareSpectra well eventual precursor m/z matching. FUN function used calculate similarity spectra. Defaults CompareSpectraParam MsCoreUtils::ndotproduct(). See MsCoreUtils::ndotproduct() details. requirePrecursor logical(1) whether target spectra considered similarity calculation precursor m/z matches precursor m/z query spectrum (considering also ppm tolerance). requirePrecursor = TRUE (default) function complete much faster, find hits target (query spectra) missing precursor m/z. suggested check first availability precursor m/z target query. requirePrecursorPeak logical(1) whether target spectra considered spectra similarity calculation peak m/z matching precursor m/z query spectrum. Defaults requirePrecursorPeak = FALSE. suggested check first availability precursor m/z query, match reported query spectra missing precursor m/z. THRESHFUN function applied similarity score define target spectra considered matching. Defaults THRESHFUN = function(x) (x >= 0.7) hence selects target spectra matching query spectrum similarity higher equal 0.7. function takes numeric vector similarity scores comparison query spectrum target spectra (returned Spectra::compareSpectra()) input returns logical vector (dimensions similarity scores) integer matches supported. toleranceRt numeric length 1 equal number query spectra defining maximal accepted (absolute) difference retention time query target spectra. default (toleranceRt = Inf) retention time-based filter considered. See help CompareSpectraParam information. percentRt numeric length 1 equal number query spectra defining maximal accepted relative difference retention time query target spectra expressed percentage query rt. percentRt = 10, similarities defined query spectrum target spectra retention time within query rt +/- 10% query. default (toleranceRt = Inf) retention time-based filter considered. Thus, consider percentRt parameter, toleranceRt set value different . See help CompareSpectraParam information. matchedPeaksCount logical(1) CompareSpectraParam(): whether also number matching peaks reported (column \"matched_peaks_count\"). number represents number peaks reported matching MAPFUN. ... CompareSpectraParam: additional parameters passed along Spectra::compareSpectra() call. THRESHFUN_REVERSE MatchForwardReverseParam: optional additional thresholding function filter results reverse score. specified format THRESHFUN expected. rtColname character(2) name spectra variable containing retention time information compounds used retention time matching (used toleranceRt Inf). can also character(1) two names . Defaults rtColname = c(\"rtime\", \"rtime\").","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","text":"matchSpectra returns MatchedSpectra() object matching results. target CompAnnotationSource matching target spectra reported. Constructor functions return instance class.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","text":"Johannes Rainer, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/CompareSpectraParam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching MS Spectra against a reference — matchSpectra,Spectra,CompDbSource,Param-method","text":"","code":"library(Spectra) #> Loading required package: S4Vectors #> Loading required package: stats4 #> Loading required package: BiocGenerics #> Loading required package: generics #>  #> Attaching package: ‘generics’ #> The following objects are masked from ‘package:base’: #>  #>     as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, #>     setequal, union #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, aperm, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, is.unsorted, lapply, #>     mapply, match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, #>     rank, rbind, rownames, sapply, saveRDS, table, tapply, unique, #>     unsplit, which.max, which.min #>  #> Attaching package: ‘S4Vectors’ #> The following object is masked from ‘package:MetaboAnnotation’: #>  #>     endoapply #> The following object is masked from ‘package:utils’: #>  #>     findMatches #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: BiocParallel library(msdata) fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L)  ## subset to selected spectra. pest_ms2 <- pest_ms2[c(808, 809, 945:955)]  ## Load a small example MassBank data set load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\"))  ## Match spectra with the default similarity score (normalized dot product) csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10) mtches <- matchSpectra(pest_ms2, minimb, csp)  mtches #> Object of class MatchedSpectra  #> Total number of matches: 16  #> Number of query objects: 13 (5 matched) #> Number of target objects: 100 (11 matched)  ## Are there any matching spectra for the first query spectrum? mtches[1] #> Object of class MatchedSpectra  #> Total number of matches: 0  #> Number of query objects: 1 (0 matched) #> Number of target objects: 100 (0 matched) ## No  ## And for the second query spectrum? mtches[2] #> Object of class MatchedSpectra  #> Total number of matches: 4  #> Number of query objects: 1 (1 matched) #> Number of target objects: 100 (4 matched) ## The second query spectrum matches 4 target spectra. The scores for these ## matches are: mtches[2]$score #> [1] 0.7869556 0.8855473 0.7234894 0.7219942  ## To access the score for the full data set mtches$score #>  [1]        NA 0.7869556 0.8855473 0.7234894 0.7219942        NA 0.7769746 #>  [8] 0.7577286        NA 0.7433718 0.7019807 0.7081274        NA 0.7320465 #> [15] 0.8106258 0.7290458 0.8168876 0.7247800 0.7412586 0.7198787        NA #> [22]        NA        NA        NA  ## Below we use a THRESHFUN that returns for each query spectrum the (first) ## best matching target spectrum. csp <- CompareSpectraParam(requirePrecursor = FALSE, ppm = 10,     THRESHFUN = function(x) which.max(x)) mtches <- matchSpectra(pest_ms2, minimb, csp) mtches #> Object of class MatchedSpectra  #> Total number of matches: 13  #> Number of query objects: 13 (13 matched) #> Number of target objects: 100 (10 matched)  ## Each of the query spectra is matched to one target spectrum length(mtches) #> [1] 13 matches(mtches) #>    query_idx target_idx        score #> 1          1          1 0.000000e+00 #> 2          2         73 8.855473e-01 #> 3          3          2 6.313687e-01 #> 4          4         44 7.769746e-01 #> 5          5         74 1.772117e-05 #> 6          6          2 7.433718e-01 #> 7          7          5 1.906998e-03 #> 8          8         53 8.168876e-01 #> 9          9         44 7.412586e-01 #> 10        10         86 4.085289e-04 #> 11        11         53 4.323403e-01 #> 12        12         47 3.469648e-03 #> 13        13         71 7.612480e-06  ## Match spectra considering also measured retention times. This requires ## that both query and target spectra have non-missing retention times. rtime(pest_ms2) #>  [1] 361.651 361.741 377.609 377.699 378.120 378.539 378.779 378.869 378.959 #> [10] 379.379 380.059 380.609 381.029 rtime(minimb) #>   [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #>  [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA  ## Target spectra don't have retention times. Below we artificially set ## retention times to show how an additional retention time filter would ## work. rtime(minimb) <- rep(361, length(minimb))  ## Matching spectra requiring a matching precursor m/z and the difference ## of retention times between query and target spectra to be <= 2 seconds. csp <- CompareSpectraParam(requirePrecursor = TRUE, ppm = 10,     toleranceRt = 2) mtches <- matchSpectra(pest_ms2, minimb, csp) mtches #> Object of class MatchedSpectra  #> Total number of matches: 4  #> Number of query objects: 13 (1 matched) #> Number of target objects: 100 (4 matched) matches(mtches) #>   query_idx target_idx     score #> 1         2         70 0.7869556 #> 2         2         73 0.8855473 #> 3         2         75 0.7234894 #> 4         2         76 0.7219942  ## Note that parameter `rtColname` can be used to define different spectra ## variables with retention time information (such as retention indices etc).  ## A `CompDb` compound annotation database could also be used with ## parameter `target`. Below we load the test `CompDb` database from the ## `CompoundDb` Bioconductor package. library(CompoundDb) #> Loading required package: AnnotationFilter fl <- system.file(\"sql\", \"CompDb.MassBank.sql\", package = \"CompoundDb\") cdb <- CompDb(fl) res <- matchSpectra(pest_ms2, cdb, CompareSpectraParam())  ## We do however not find any matches since the used compound annotation ## database contains only a very small subset of the MassBank. res #> Object of class MatchedSpectra  #> Total number of matches: 0  #> Number of query objects: 13 (0 matched) #> Number of target objects: 70 (0 matched)  ## As `target` we have now however the MS2 spectra data from the compound ## annotation database target(res) #> MSn data (Spectra) with 70 spectra in a MsBackendCompDb backend: #>       msLevel precursorMz  polarity #>     <integer>   <numeric> <integer> #> 1           2      179.07         1 #> 2           2      179.07         1 #> 3           2      179.07         1 #> 4           2      179.07         1 #> 5           2      179.07         1 #> ...       ...         ...       ... #> 66          2     337.091         1 #> 67          2     337.091         1 #> 68          2     337.091         1 #> 69          2     337.091         1 #> 70          2     337.091         1 #>  ... 46 more variables/columns. #>  Use  'spectraVariables' to list all of them. #>  data source: MassBank  #>  version: 2020.09  #>  organism: NA   ## See the package vignette for details, descriptions and more examples, ## also on how to retrieve e.g. MassBank reference databases from ## Bioconductor's AnnotationHub."},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of generic objects matches — addMatches","title":"Representation of generic objects matches — addMatches","text":"Matches query target generic objects can represented Matched object. default, data accessors work left joins query target object, .e. values returned query object eventual duplicated entries (values) query object matches one target object. See also Creation subsetting well Extracting data sections details information. Matched object allows represent matches one-dimensional query target objects (e.g. numeric list), two-dimensional objects (data.frame matrix) complex structures SummarizedExperiments QFeatures. Combinations different data types also supported. Matches represented elements one-dimensional objects, rows two-dimensional objects (including SummarizedExperiment QFeatures). QFeatures::QFeatures() objects matches one assays within object supported.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of generic objects matches — addMatches","text":"","code":"addMatches(object, ...)  endoapply(X, FUN, ...)  filterMatches(object, param, ...)  matchedData(object, ...)  queryVariables(object, ...)  targetVariables(object, ...)  Matched(   query = list(),   target = list(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score = numeric()),   queryAssay = character(),   targetAssay = character(),   metadata = list() )  # S4 method for class 'Matched' length(x)  # S4 method for class 'Matched' show(object)  # S4 method for class 'Matched,ANY,ANY,ANY' x[i, j, ..., drop = FALSE]  matches(object)  target(object)  # S4 method for class 'Matched' query(x, pattern, ...)  targetIndex(object)  queryIndex(object)  whichTarget(object)  whichQuery(object)  # S4 method for class 'Matched' x$name  # S4 method for class 'Matched' colnames(x)  scoreVariables(object)  # S4 method for class 'Matched' queryVariables(object)  # S4 method for class 'Matched' targetVariables(object)  # S4 method for class 'Matched' matchedData(object, columns = colnames(object), ...)  pruneTarget(object)  # S4 method for class 'Matched,missing' filterMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   index = integer(),   keep = TRUE,   ... )  SelectMatchesParam(   queryValue = numeric(),   targetValue = numeric(),   queryColname = character(),   targetColname = character(),   index = integer(),   keep = TRUE )  TopRankedMatchesParam(n = 1L, decreasing = FALSE)  ScoreThresholdParam(threshold = 0, above = FALSE, column = \"score\")  # S4 method for class 'Matched,SelectMatchesParam' filterMatches(object, param, ...)  # S4 method for class 'Matched,TopRankedMatchesParam' filterMatches(object, param, ...)  # S4 method for class 'Matched,ScoreThresholdParam' filterMatches(object, param, ...)  SingleMatchParam(   duplicates = c(\"remove\", \"closest\", \"top_ranked\"),   column = \"score\",   decreasing = TRUE )  # S4 method for class 'Matched,SingleMatchParam' filterMatches(object, param, ...)  # S4 method for class 'Matched' addMatches(   object,   queryValue = integer(),   targetValue = integer(),   queryColname = character(),   targetColname = character(),   score = rep(NA_real_, length(queryValue)),   isIndex = FALSE )  # S4 method for class 'ANY' endoapply(X, FUN, ...)  # S4 method for class 'Matched' endoapply(X, FUN, ...)  # S4 method for class 'Matched' lapply(X, FUN, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of generic objects matches — addMatches","text":"object Matched object. ... additional parameters. X Matched object. FUN lapply endoapply: user defined function takes Matched object first parameter possibly additional parameters (need provided lapply endoapply call. lapply FUN can return object endoapply must return Matched object. param filterMatches: parameter object select customize filtering procedure. query object query elements. target object elements query matched. matches data.frame columns \"query_idx\" (integer), \"target_idx\" (integer) \"score\" (numeric) representing n:m mapping elements query target objects. queryAssay character needs specified query QFeatures. case, queryAssay expected name one assays query (one matching performed). targetAssay character needs specified target QFeatures. case, targetAssay expected name one assays target (one matching performed). metadata list optional additional metadata. x Matched object. integer logical defining query elements keep. j [: ignored. drop [: ignored. pattern query: ignored. name $: name column (variable) extract. columns matchedData: character vector column names variables extracted. queryValue SelectMatchesParam: vector values search query (query 1-dimensional) column queryColname query (query 2-dimensional). addMatches: either index query value column queryColname query defining (together targetValue) pair query target elements match manually added. Lengths queryValue targetValue match. targetValue SelectMatchesParam: vector values search target (target 1-dimensional) column targetColname target (target 2-dimensional). addMatches: either index target value column targetColname target defining (together queryValue) pair query target elements match manually added. Lengths queryValue targetValue match. queryColname SelectMatchesParam: query 2-dimensional represents column query elements queryValue compared. targetColname SelectMatchesParam: query 2-dimensional represents column target elements targetValue compared. index SelectMatchesParam: indices matches keep (keep = TRUE) drop (keep = FALSE). keep SelectMatchesParam: logical. keep = TRUE matches kept, keep = FALSE removed. n TopRankedMatchesParam: integer(1) number best ranked matches keep query element. decreasing TopRankedMatchesParam: logical(1) whether scores ordered increasing decreasing. Defaults decreasing = FALSE. threshold ScoreThresholdParam : numeric(1) specifying threshold consider filtering. ScoreThresholdParam : logical(1) specifying whether keep matches (= TRUE) (= FALSE) certain threshold. column ScoreThresholdParam: character(1) specifying name score variable consider filtering (default column = \"score\"). SingleMatchParam: character(1) defining name column used de-duplication. See description SingleMatchParam Filtering subsetting section details. duplicates SingleMatchParam: character(1) defining de-duplication strategy. See description SingleMatchParam Filtering subsetting subsection choices details. score addMatches: numeric (length queryValue) data.frame (number rows queryValue) specifying scores matches add. specified, NA used score. isIndex addMatches: specifies queryValue targetValue expected vectors indices.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representation of generic objects matches — addMatches","text":"See individual method description details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"creation-and-general-handling","dir":"Reference","previous_headings":"","what":"Creation and general handling","title":"Representation of generic objects matches — addMatches","text":"Matched object returned result matchValues() function. Alternatively, Matched objects can also created Matched function providing query target objects well matches data.frame two columns integer indices defining elements query match element target. addMatches: add new matches existing object. Parameters queryValue targetValue allow define element(s) query target considered matching. isIndex = TRUE, queryValue targetValue considered integer indices identifying matching elements query target, respectively. Alternatively (isIndex = FALSE) queryValue targetValue can elements columns queryColname targetColname can used identify matching elements. Note case first matching pair added. Parameter score allows provide score match. can numeric score data.frame additional information manually added matches. cases length (number rows) match length queryValue. See examples information. endoapply: applies user defined function FUN subset matches Matched object corresponding query element (.e. x[] 1 length(x)). results combined single Matched object representing updated matches. Note FUN return Matched object. lapply: applies user defined function FUN subset matches Matched object query element (.e. x[] 1 length(x)). returns list length(object) elements element output FUN applied subset matches.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"filtering-and-subsetting","dir":"Reference","previous_headings":"","what":"Filtering and subsetting","title":"Representation of generic objects matches — addMatches","text":"[: subset object selecting query object elements keep parameter . resulting object contain matches selected query elements. target object default returned -. filterMatches: filter matches Matched object using different approaches depending class param: ScoreThresholdParam: keeps matches whose score strictly strictly certain threshold (respectively parameter = TRUE = FALSE). name column containing scores used filtering can specified parameter column. default column \"score\". variable present Matched object. name score variables (present) can provided (names score variables can obtained scoreVariables() function). example column = \"score_rt\" can used filter matches based retention time scores Matched objects returned matchValues() param objects involving retention time comparison used. SelectMatchesParam: keeps removes (respectively parameter keep = TRUE keep = FALSE) matches corresponding certain indices values query target. queryValue targetValue provided, matches value pairs kept removed. Parameter indexallows filter matches providing index [matches()] matrix. Note thatfilterMatchesremoves matches [matches()] matrix theMatchedobject thus alter thequeryortarget` object. See examples information. SingleMatchParam: reduces matches keep () single match per query. deduplication strategy can defined parameter duplicates: duplicates = \"remove\": matches query elements matching one target element removed. duplicates = \"closest\": keep closest match query element. closest match defined value(s) score (eventually score_rt, present). one match smallest value () column(s) retained. equivalent TopRankedMatchesParam(n = 1L, decreasing = FALSE). duplicates = \"top_ranked\": select best ranking match query element. Parameter column allows specify column matches ranked (use targetVariables(object) scoreVariables(object) list possible columns). Parameter decreasing allows define whether match highest (decreasing = TRUE) lowest (decreasing = FALSE) value column query selected. TopRankedMatchesParam: query element matches ranked according score n best kept (n larger number matches given query element matches returned). ranking (ordering) R's rank function used absolute values scores (variable \"score\"), thus, smaller score values (representing e.g. smaller differences expected observed m/z values) considered better. setting parameter decreasing = TRUE matches can ranked decreasing order (.e. higher scores ranked higher thus selected). besides variable \"score\" also variable \"score_rt\" available Matched object (case Matched object returned matchValues() param objects involving retention time comparison), ordering matches based product ranks two variables (ranking retention time differences performed absolute value \"score_rt\"). Thus, matches small (, depending parameter decreasing, large) values \"score\" \"score_rt\" returned. pruneTarget: cleans object removing non-matched target elements.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"extracting-data","dir":"Reference","previous_headings":"","what":"Extracting data","title":"Representation of generic objects matches — addMatches","text":"$ extracts single variable Matched x. variables can extracted can listed using colnames(x). variables can belong query, target related matches (e.g. score match). query (target) object two dimensional, columns can extracted (prefix \"target_\" used columns target object) otherwise query (target) single dimension (e.g. list character) whole object can extracted x$query (x$target). precisely, query (target) SummarizedExperiment columns rowData(query) (rowData(target)) extracted; query (target) QFeatures::QFeatures() columns rowData assay specified queryAssay (targetAssay) slot extracted. matching scores available variable \"score\". Similar left join query target elements, function returns value query element, eventual duplicated values query elements matching one target element. variables target data.frame extracted, NA reported entries corresponding query elements match target element. See examples details. length returns number query elements. matchedData allows extract multiple variables contained Matched object DataFrame. Parameter columns allows define columns (variables) returned (defaults columns = colnames(object)). single column returned DataFrame constructed way $. , like $, function performs left join variables query target objects returning values query elements (eventually returning duplicated elements query elements matching multiple target elements) values target elements matched respective query elements (NA target element matched query element). matches returns data.frame actual matching information columns \"query_idx\" (index element query), \"target_idx\" (index element target) \"score\" (score match) eventual additional columns. target returns target object. targetIndex returns indices matched targets order assigned query elements. length returned integer vector equal total number matches object. targetIndex queryIndex aligned, .e. element represent matched query-target pair. query returns query object. queryIndex returns indices query elements matches target elements. length returned integer vector equal total number matches object. targetIndex queryIndex aligned, .e. element represent matched query-target pair. queryVariables returns names variables (columns) query. scoreVariables returns names score variables stored Matched object (precisely names variables matches(object) containing string \"score\" name ignoring case). targetVariables returns names variables (columns) target (prefixed \"target_\"). whichTarget returns integer indices elements target match least one element query. whichQuery returns integer indices elements query match least one element target.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representation of generic objects matches — addMatches","text":"Andrea Vicini, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/Matched.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of generic objects matches — addMatches","text":"","code":"## Creating a `Matched` object. q1 <- data.frame(col1 = 1:5, col2 = 6:10) t1 <- data.frame(col1 = 11:16, col2 = 17:22) ## Define matches between query row 1 with target row 2 and, query row 2 ## with target rows 2,3,4 and query row 5 with target row 5. mo <- Matched(     q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),                                  target_idx = c(2L, 2L, 3L, 4L, 5L),                                  score = seq(0.5, 0.9, by = 0.1))) mo #> Object of class Matched  #> Total number of matches: 5  #> Number of query objects: 5 (3 matched) #> Number of target objects: 6 (4 matched)  ## Which of the query elements (rows) match at least one target ## element (row)? whichQuery(mo) #> [1] 1 2 5  ## Which target elements (rows) match at least one query element (row)? whichTarget(mo) #> [1] 2 3 4 5  ## Extracting variable \"col1\" from query object . mo$col1 #> [1] 1 2 2 2 3 4 5  ## We have duplicated values for the entries of `col1` related to query ## elements (rows) matched to multiple rows of the target object). The ## value of `col1` is returned for each element (row) in the query.  ## Extracting variable \"col1\" from target object. To access columns from ## target we have to prefix the name of the column by `\"target_\"`. ## Note that only values of `col1` for rows matching at least one query ## row are returned and an NA is reported for query rows without matching ## target rows. mo$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The 3rd and 4th query rows do not match any target row, thus `NA` is ## returned.  ## `matchedData` can be used to extract all (or selected) columns ## from the object. Same as with `$`, a left join between the columns ## from the query and the target is performed. Below we extract selected ## columns from the object as a DataFrame. res <- matchedData(mo, columns = c(\"col1\", \"col2\", \"target_col1\",                                    \"target_col2\")) res #> DataFrame with 7 rows and 4 columns #>          col1      col2 target_col1 target_col2 #>     <integer> <integer>   <integer>   <integer> #> 1           1         6          12          18 #> 2           2         7          12          18 #> 2.1         2         7          13          19 #> 2.2         2         7          14          20 #> 3           3         8          NA          NA #> 4           4         9          NA          NA #> 5           5        10          15          21 res$col1 #> [1] 1 2 2 2 3 4 5 res$target_col1 #> [1] 12 12 13 14 NA NA 15  ## With the `queryIndex` and `targetIndex` it is possible to extract the ## indices of the matched query-target pairs: queryIndex(mo) #> [1] 1 2 2 2 5 targetIndex(mo) #> [1] 2 2 3 4 5  ## Hence, the first match is between the query with index 1 to the target ## with index 2, then, query with index 2 is matched to target with index 2 ## and so on.  ## The example matched object contains all query and all target ## elements (rows). Below we subset the object keeping only query rows that ## are matched to at least one target row. mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now only 3 query rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains all 5 query rows: nrow(query(mo)) #> [1] 5  ## Both objects contain however still the full target object: nrow(target(mo)) #> [1] 6 nrow(target(mo_sub)) #> [1] 6  ## With the `pruneTarget` we can however reduce also the target rows to ## only those that match at least one query row mo_sub <- pruneTarget(mo_sub) nrow(target(mo_sub)) #> [1] 4  ######## ## Creating a `Matched` object with a `data.frame` for `query` and a `vector` ## for `target`. The matches are specified in the same way as the example ## before.  q1 <- data.frame(col1 = 1:5, col2 = 6:10) t2 <- 11:16 mo <- Matched(q1, t2, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),     target_idx = c(2L, 2L, 3L, 4L, 5L), score = seq(0.5, 0.9, by = 0.1)))  ## *target* is a simple vector and has thus no columns. The matched values ## from target, if it does not have dimensions and hence column names, can ## be retrieved with `$target` mo$target #> [1] 12 12 13 14 NA NA 15  ## Note that in this case \"target\" is returned by the function `colnames` colnames(mo) #> [1] \"col1\"   \"col2\"   \"target\" \"score\"   ## As before, we can extract all data as a `DataFrame` res <- matchedData(mo) res #> DataFrame with 7 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 2.2         2         7     14       0.8 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     15       0.9  ## Note that the columns of the obtained `DataFrame` are the same as the ## corresponding vectors obtained with `$` res$col1 #> [1] 1 2 2 2 3 4 5 res$target #> [1] 12 12 13 14 NA NA 15  ## Also subsetting and pruning works in the same way as the example above.  mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now only 3 query rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains all 5 query rows: nrow(query(mo)) #> [1] 5  ## Both object contain however still the full target object: length(target(mo)) #> [1] 6 length(target(mo_sub)) #> [1] 6  ## Reducing the target elements to only those that match at least one query ## row mo_sub <- pruneTarget(mo_sub) length(target(mo_sub)) #> [1] 4  ######## ## Filtering `Matched` with `filterMatches`  ## Inspecting the matches in `mo`: mo$col1 #> [1] 1 2 2 2 3 4 5 mo$target #> [1] 12 12 13 14 NA NA 15  ## We have thus target *12* matched to both query elements with values 1 and ## 2, and query element 2 is matching 3 target elements. Let's assume we want ## to resolve this multiple mappings to keep from them only the match between ## query 1 (column `\"col1\"` containing value `1`) with target 1 (value `12`) ## and query 2 (column `\"col1\"` containing value `2`) with target 2 (value ## `13`). In addition we also want to keep query element 5 (value `5` in ## column `\"col1\"`) with the target with value `15`: mo_sub <- filterMatches(mo,     SelectMatchesParam(queryValue = c(1, 2, 5), queryColname = \"col1\",                        targetValue = c(12, 13, 15))) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2 target     score #>   <integer> <integer> <AsIs> <numeric> #> 1         1         6     12       0.5 #> 2         2         7     13       0.7 #> 3         3         8     NA        NA #> 4         4         9     NA        NA #> 5         5        10     15       0.9  ## Alternatively to specifying the matches to filter with `queryValue` and ## `targetValue` it is also possible to specify directly the index of the ## match(es) in the `matches` `data.frame`: matches(mo) #>   query_idx target_idx score #> 1         1          2   0.5 #> 2         2          2   0.6 #> 3         2          3   0.7 #> 4         2          4   0.8 #> 5         5          5   0.9  ## To keep only matches like in the example above we could use: mo_sub <- filterMatches(mo, SelectMatchesParam(index = c(1, 3, 5))) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2 target     score #>   <integer> <integer> <AsIs> <numeric> #> 1         1         6     12       0.5 #> 2         2         7     13       0.7 #> 3         3         8     NA        NA #> 4         4         9     NA        NA #> 5         5        10     15       0.9  ## Note also that, instead of keeping the specified matches, it would be ## possible to remove them by setting `keep = FALSE`. Below we remove ## selected matches from the object: mo_sub <- filterMatches(mo,     SelectMatchesParam(queryValue = c(2, 2), queryColname = \"col1\",                        targetValue = c(12, 14), keep = FALSE)) mo_sub$col1 #> [1] 1 2 3 4 5 mo_sub$target #> [1] 12 13 NA NA 15  ## As alternative to *manually* selecting matches it is also possible to ## filter matches keeping only the *best matches* using the ## `TopRankedMatchesParam`. This will rank matches for each query based on ## their *score* value and select the best *n* matches with lowest score ## values (i.e. smallest difference in m/z values). mo_sub <- filterMatches(mo, TopRankedMatchesParam(n = 1L)) matchedData(mo_sub) #> DataFrame with 5 rows and 4 columns #>        col1      col2 target     score #>   <integer> <integer> <AsIs> <numeric> #> 1         1         6     12       0.5 #> 2         2         7     12       0.6 #> 3         3         8     NA        NA #> 4         4         9     NA        NA #> 5         5        10     15       0.9  ## Additionally it is possible to select matches based on a threshold ## for their *score*. Below we keep matches with score below 0.75 (one ## could select matches with *score* greater than the threshold by setting ## `ScoreThresholdParam` parameter `above = TRUE`. mo_sub <- filterMatches(mo, ScoreThresholdParam(threshold = 0.75)) matchedData(mo_sub) #> DataFrame with 6 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     NA        NA  ######## ## Selecting the best match for each `query` element with `endoapply`  ## It is also possible to select for each `query` element the match with the ## lowest score using `endoapply`. We manually define a function to select ## the best match for each query and give it as input to `endoapply` ## together with the `Matched` object itself. We obtain the same results as ## in the `filterMatches` example above.  FUN <- function(x) {     if(nrow(x@matches) > 1)         x@matches <- x@matches[order(x@matches$score)[1], , drop = FALSE]     x }  mo_sub <- endoapply(mo, FUN) #> Error in as(from, to_class, strict = FALSE): no method or default for coercing “list” to “Matched” matchedData(mo_sub) #> DataFrame with 6 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     NA        NA  ######## ## Adding matches using `addMatches`  ## `addMatches` allows to manually add matches. Below we add a new match ## between the `query` element with a value of `1` in column `\"col1\"` and ## the target element with a value of `15`. Parameter `score` allows to ## assign a score value to the match. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15, score = 1.40) matchedData(mo_add) #> DataFrame with 8 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 1.1         1         6     15       1.4 #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 2.2         2         7     14       0.8 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     15       0.9 ## Matches are always sorted by `query`, thus, the new match is listed as ## second match.  ## Alternatively, we can also provide a `data.frame` with parameter `score` ## which enables us to add additional information to the added match. Below ## we define the score and an additional column specifying that this match ## was added manually. This information will then also be available in the ## `matchedData`. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15, score = data.frame(score = 5, manual = TRUE)) matchedData(mo_add) #> DataFrame with 8 rows and 5 columns #>          col1      col2 target     score    manual #>     <integer> <integer> <AsIs> <numeric> <logical> #> 1           1         6     12       0.5        NA #> 1.1         1         6     15       5.0      TRUE #> 2           2         7     12       0.6        NA #> 2.1         2         7     13       0.7        NA #> 2.2         2         7     14       0.8        NA #> 3           3         8     NA        NA        NA #> 4           4         9     NA        NA        NA #> 5           5        10     15       0.9        NA  ## The match will get a score of NA if we're not providing any score. mo_add <- addMatches(mo, queryValue = 1, queryColname = \"col1\",     targetValue = 15) matchedData(mo_add) #> DataFrame with 8 rows and 4 columns #>          col1      col2 target     score #>     <integer> <integer> <AsIs> <numeric> #> 1           1         6     12       0.5 #> 1.1         1         6     15        NA #> 2           2         7     12       0.6 #> 2.1         2         7     13       0.7 #> 2.2         2         7     14       0.8 #> 3           3         8     NA        NA #> 4           4         9     NA        NA #> 5           5        10     15       0.9  ## Creating a `Matched` object with a `SummarizedExperiment` for `query` and ## a `vector` for `target`. The matches are specified in the same way as ## the example before. library(SummarizedExperiment) #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: ‘MatrixGenerics’ #> The following objects are masked from ‘package:matrixStats’: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: ‘Biobase’ #> The following object is masked from ‘package:MatrixGenerics’: #>  #>     rowMedians #> The following objects are masked from ‘package:matrixStats’: #>  #>     anyMissing, rowMedians q1 <- SummarizedExperiment(   assays = data.frame(matrix(NA, 5, 2)),   rowData = data.frame(col1 = 1:5, col2 = 6:10),   colData = data.frame(cD1 = c(NA, NA), cD2 = c(NA, NA))) t1 <- data.frame(col1 = 11:16, col2 = 17:22) ## Define matches between row 1 in rowData(q1) with target row 2 and, ## rowData(q1) row 2 with target rows 2,3,4 and rowData(q1) row 5 with target ## row 5. mo <- Matched(     q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),                                 target_idx = c(2L, 2L, 3L, 4L, 5L),                                  score = seq(0.5, 0.9, by = 0.1))) mo #> Object of class Matched  #> Total number of matches: 5  #> Number of query objects: 5 (3 matched) #> Number of target objects: 6 (4 matched)  ## Which of the query elements (rows) match at least one target ## element (row)? whichQuery(mo) #> [1] 1 2 5  ## Which target elements (rows) match at least one query element (row)? whichTarget(mo) #> [1] 2 3 4 5  ## Extracting variable \"col1\" from rowData(q1). mo$col1 #> [1] 1 2 2 2 3 4 5  ## We have duplicated values for the entries of `col1` related to rows of ## rowData(q1) matched to multiple rows of the target data.frame t1. The ## value of `col1` is returned for each row in the rowData of query.  ## Extracting variable \"col1\" from target object. To access columns from ## target we have to prefix the name of the column by `\"target_\"`. ## Note that only values of `col1` for rows matching at least one row in ## rowData of query are returned and an NA is reported for those without ## matching target rows. mo$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The 3rd and 4th query rows do not match any target row, thus `NA` is ## returned.  ## `matchedData` can be used to extract all (or selected) columns ## from the object. Same as with `$`, a left join between the columns ## from the query and the target is performed. Below we extract selected ## columns from the object as a DataFrame. res <- matchedData(mo, columns = c(\"col1\", \"col2\", \"target_col1\",                                   \"target_col2\")) res #> DataFrame with 7 rows and 4 columns #>        col1      col2 target_col1 target_col2 #>   <integer> <integer>   <integer>   <integer> #> 1         1         6          12          18 #> 2         2         7          12          18 #> 2         2         7          13          19 #> 2         2         7          14          20 #> 3         3         8          NA          NA #> 4         4         9          NA          NA #> 5         5        10          15          21 res$col1 #> [1] 1 2 2 2 3 4 5 res$target_col1 #> [1] 12 12 13 14 NA NA 15  ## The example `Matched` object contains all rows in the ## `rowData` of the `SummarizedExperiment` and all target rows. Below we ## subset the object keeping only rows that are matched to at least one ## target row. mo_sub <- mo[whichQuery(mo)]  ## mo_sub contains now a `SummarizedExperiment` with only 3 rows: nrow(query(mo_sub)) #> [1] 3  ## while the original object contains a `SummarizedExperiment` with all 5 ## rows: nrow(query(mo)) #> [1] 5  ## Both objects contain however still the full target object: nrow(target(mo)) #> [1] 6 nrow(target(mo_sub)) #> [1] 6  ## With the `pruneTarget` we can however reduce also the target rows to ## only those that match at least one in the `rowData` of query mo_sub <- pruneTarget(mo_sub) nrow(target(mo_sub)) #> [1] 4"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of Spectra matches — MatchedSpectra","title":"Representation of Spectra matches — MatchedSpectra","text":"Matches query target spectra can represented MatchedSpectra object. Functions like matchSpectra() function return type object. default, data accessors work left joins query target spectra, .e. values returned query spectrum eventual duplicated entries (values) query spectrum matches one target spectrum.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of Spectra matches — MatchedSpectra","text":"","code":"MatchedSpectra(   query = Spectra(),   target = Spectra(),   matches = data.frame(query_idx = integer(), target_idx = integer(), score = numeric()) )  # S4 method for class 'MatchedSpectra' spectraVariables(object)  # S4 method for class 'MatchedSpectra' queryVariables(object)  # S4 method for class 'MatchedSpectra' targetVariables(object)  # S4 method for class 'MatchedSpectra' colnames(x)  # S4 method for class 'MatchedSpectra' x$name  # S4 method for class 'MatchedSpectra' spectraData(object, columns = spectraVariables(object))  # S4 method for class 'MatchedSpectra' matchedData(object, columns = spectraVariables(object), ...)  # S4 method for class 'MatchedSpectra' addProcessing(object, FUN, ..., spectraVariables = character())  # S4 method for class 'MatchedSpectra' plotSpectraMirror(   x,   xlab = \"m/z\",   ylab = \"intensity\",   main = \"\",   scalePeaks = FALSE,   ... )  # S4 method for class 'MatchedSpectra,MsBackend' setBackend(object, backend, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of Spectra matches — MatchedSpectra","text":"query Spectra query spectra. target Spectra spectra query matched. matches data.frame columns \"query_idx\" (integer), \"target_idx\" (integer) \"score\" (numeric) representing n:m mapping elements query target Spectra. object MatchedSpectra object. x MatchedSpectra object. name $: name spectra variable extract. columns spectraData: character vector spectra variable names extracted. ... addProcessing: additional parameters function FUN. plotSpectraMirror: additional parameters passed plotting functions. FUN addProcessing: function applied peak matrix spectrum object. See Spectra::Spectra() details. spectraVariables addProcessing: character additional spectra variables passed along function defined FUN. See Spectra::Spectra() details. xlab plotSpectraMirror: label x-axis. ylab plotSpectraMirror: label y-axis. main plotSpectraMirror: optional title plot. scalePeaks plotSpectraMirror: logical(1) peak intensities (per spectrum) scaled total sum one (per spectrum) prior plotting. backend setBackend: instance object extending Spectra::MsBackend. See help Spectra::setBackend() details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Representation of Spectra matches — MatchedSpectra","text":"See individual method desciption details.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"creation-subset-and-filtering","dir":"Reference","previous_headings":"","what":"Creation, subset and filtering","title":"Representation of Spectra matches — MatchedSpectra","text":"MatchedSpectra objects result object matchSpectra(). generally needed, MatchedSpectra objects can also created MatchedSpectra function providing query target Spectra objects well data.frame matches query target elements. data frame expected columns \"query_idx\", \"target_idx\" integer indices query target objects matched column \"score\" numeric score match. MatchedSpectra objects can subset using: [ subset MatchedSpectra selecting query spectra keep parameter . target spectra default returned -. pruneTarget cleans MatchedSpectra object removing non-matched target spectra. addition, MatchedSpectra can filtered filtering approaches defined Matched() objects: SelectMatchesParam(), TopRankedMatchesParam() ScoreThresholdParam().","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"extracting-data","dir":"Reference","previous_headings":"","what":"Extracting data","title":"Representation of Spectra matches — MatchedSpectra","text":"$ extracts single spectra variable MatchedSpectra x. Use spectraVariables get available spectra variables. Prefix \"target_\" used spectra variables target Spectra. matching scores available spectra variable \"score\". Similar left join query target spectra, function returns value query spectrum eventual duplicated values query spectra matching one target spectrum. spectra variables target spectra extracted, NA reported query spectra match target spectra. See examples details. length returns number query spectra. matchedData spectraData . query returns query Spectra. queryVariables returns spectraVariables query. spectraData returns spectra variables query /target Spectra DataFrame. Parameter columns allows define variables returned (defaults columns = spectraVariables(object)), spectra variable names target spectra need prefixed target_ (e.g. target_msLevel get MS level target spectra). score matching function returned spectra variable \"score\". Similar $, function performs left join spectra variables query target spectra returning values query spectra (eventually returning duplicated elements query spectra matching multiple target spectra) values target spectra matched respective query spectra. See help $ examples details. spectraVariables returns available spectra variables query target spectra. prefix \"target_\" used label spectra variables target spectra (e.g. name spectra variable MS level target spectra called \"target_msLevel\"). target returns target Spectra. targetVariables returns spectraVariables target (prefixed \"target_\"). whichTarget returns integer indices spectra target match least spectrum query. whichQuery returns integer indices spectra query match least spectrum target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"data-manipulation-and-plotting","dir":"Reference","previous_headings":"","what":"Data manipulation and plotting","title":"Representation of Spectra matches — MatchedSpectra","text":"addProcessing: add processing step query target Spectra object. Additional parameters FUN can passed via .... See addProcessing documentation Spectra::Spectra() information. plotSpectraMirror: creates mirror plot query matching target spectrum. Can applied MatchedSpectra single query spectrum. Setting parameter scalePeaks = TRUE scale peak intensities per spectrum total sum one better graphical visualization. Additional plotting parameters can passed .... setBackend: allows change backend query target Spectra::Spectra() object. function return MatchedSpectra object query target Spectra changed specified backend, can backend extending Spectra::MsBackend.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Representation of Spectra matches — MatchedSpectra","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/MatchedSpectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of Spectra matches — MatchedSpectra","text":"","code":"## Creating a dummy MatchedSpectra object. library(Spectra) df1 <- DataFrame(     msLevel = 2L, rtime = 1:10,     spectrum_id = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\")) df2 <- DataFrame(     msLevel = 2L, rtime = rep(1:10, 20),     spectrum_id = rep(c(\"A\", \"B\", \"C\", \"D\", \"E\"), 20)) sp1 <- Spectra(df1) sp2 <- Spectra(df2) ## Define matches between query spectrum 1 with target spectra 2 and 5, ## query spectrum 2 with target spectrum 2 and query spectrum 4 with target ## spectra 8, 12 and 15. ms <- MatchedSpectra(     sp1, sp2, matches = data.frame(query_idx = c(1L, 1L, 2L, 4L, 4L, 4L),                                    target_idx = c(2L, 5L, 2L, 8L, 12L, 15L),                                    score = 1:6))  ## Which of the query spectra match at least one target spectrum? whichQuery(ms) #> [1] 1 2 4  ## Extracting spectra variables: accessor methods for spectra variables act ## as \"left joins\", i.e. they return a value for each query spectrum, with ## eventually duplicated elements if one query spectrum matches more than ## one target spectrum.  ## Which target spectrum matches at least one query spectrum? whichTarget(ms) #> [1]  2  5  8 12 15  ## Extracting the retention times of the query spectra. ms$rtime #>  [1]  1  1  2  3  4  4  4  5  6  7  8  9 10  ## We have duplicated retention times for query spectrum 1 (matches 2 target ## spectra) and 4 (matches 3 target spectra). The retention time is returned ## for each query spectrum.  ## Extracting retention times of the target spectra. Note that only retention ## times for target spectra matching at least one query spectrum are returned ## and an NA is reported for query spectra without matching target spectrum. ms$target_rtime #>  [1]  2  5  2 NA  8  2  5 NA NA NA NA NA NA  ## The first query spectrum matches target spectra 2 and 5, thus their ## retention times are returned as well as the retention time of the second ## target spectrum that matches also query spectrum 2. The 3rd query spectrum ## does match any target spectrum, thus `NA` is returned. Query spectrum 4 ## matches target spectra 8, 12, and 15, thus the next reported retention ## times are those from these 3 target spectra. None of the remaining 6 query ## spectra matches any target spectra and thus `NA` is reported for each of ## them.  ## With `queryIndex` and `targetIndex` it is possible to extract the indices ## of the matched query-index pairs queryIndex(ms) #> [1] 1 1 2 4 4 4 targetIndex(ms) #> [1]  2  5  2  8 12 15  ## The first match is between query index 1 and target index 2, the second ## match between query index 1 and target index 5 and so on. ## We could use these indices to extract a `Spectra` object containing only ## matched target spectra and assign a spectra variable with the indices of ## the query spectra matched_target <- target(ms)[targetIndex(ms)] matched_target$query_index <- queryIndex(ms)  ## This `Spectra` object thus contains information from the matching, but ## is a *conventional* `Spectra` object that could be used for further ## analyses.  ## `spectraData` can be used to extract all (or selected) spectra variables ## from the object. Same as with `$`, a left join between the specta ## variables from the query spectra and the target spectra is performed. The ## prefix `\"target_\"` is used to label the spectra variables from the target ## spectra. Below we extract selected spectra variables from the object. res <- spectraData(ms, columns = c(\"rtime\", \"spectrum_id\",     \"target_rtime\", \"target_spectrum_id\")) res #> DataFrame with 13 rows and 4 columns #>         rtime spectrum_id target_rtime target_spectrum_id #>     <integer> <character>    <integer>        <character> #> 1           1           a            2                  B #> 2           1           a            5                  E #> 3           2           b            2                  B #> 4           3           c           NA                 NA #> 5           4           d            8                  C #> ...       ...         ...          ...                ... #> 9           6           f           NA                 NA #> 10          7           g           NA                 NA #> 11          8           h           NA                 NA #> 12          9           i           NA                 NA #> 13         10           j           NA                 NA res$spectrum_id #>  [1] \"a\" \"a\" \"b\" \"c\" \"d\" \"d\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" res$target_spectrum_id #>  [1] \"B\" \"E\" \"B\" NA  \"C\" \"B\" \"E\" NA  NA  NA  NA  NA  NA   ## Again, all values for query spectra are returned and for query spectra not ## matching any target spectrum NA is reported as value for the respecive ## variable.  ## The example matched spectra object contains all query and all target ## spectra. Below we subset the object keeping only query spectra that are ## matched to at least one target spectrum. ms_sub <- ms[whichQuery(ms)]  ## ms_sub contains now only 3 query spectra: length(query(ms_sub)) #> [1] 3  ## while the original object contains all 10 query spectra: length(query(ms)) #> [1] 10  ## Both object contain however still the full target `Spectra`: length(target(ms)) #> [1] 200 length(target(ms_sub)) #> [1] 200  ## With the `pruneTarget` we can however reduce also the target spectra to ## only those that match at least one query spectrum ms_sub <- pruneTarget(ms_sub) length(target(ms_sub)) #> [1] 5"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"createStandardMixes function defines groups (mixes) compounds (standards) dissimilar m/z values. expected size groups can defined parameters max_nstd min_nstd minimum required difference m/z values within group parameter min_diff. group assignment reported additional column result data frame.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"","code":"createStandardMixes(   x,   max_nstd = 10,   min_nstd = 5,   min_diff = 2,   iterativeRandomization = FALSE )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"x numeric matrix row names representing compounds columns representing different adducts. matrix m/z values different adducts compounds e.g. created MetaboCoreUtils::mass2mz() function. max_nstd numeric number maximum standards per group. min_nstd numeric number minimum standards per group. needed using iterativeRandomization = TRUE. min_diff numeric Minimum difference considering two values distinct. iterativeRandomization logical default FALSE. set TRUE, createStandardMixes randomly rearrange rows x user inputs satisfied.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"data.frame created adding column group input x matrix, comprising group number compound.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"Users aware function iterates x, compounds bottom matrix complicated group, possibility compounds grouped others. advise specifyiong iterativeRandomization = TRUE even takes time.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"Philippine Louail","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/createStandardMixes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Standard Mixes from a Matrix of Standard Compounds — createStandardMixes","text":"","code":"## Iterative grouping only x <- matrix(c(135.0288, 157.0107, 184.0604, 206.0424, 265.1118, 287.0937,               169.0356, 191.0176, 468.9809, 490.9628, 178.0532, 200.0352),             ncol = 2, byrow = TRUE,             dimnames = list(c(\"Malic Acid\", \"Pyridoxic Acid\", \"Thiamine\",                                 \"Uric acid\", \"dUTP\", \"N-Formyl-L-methionine\"),                              c(\"adduct_1\", \"adduct_2\"))) result <- createStandardMixes(x, max_nstd = 3, min_diff = 2)  ## Randomize grouping set.seed(123) x <- matrix(c(349.0544, 371.0363, 325.0431, 347.0251, 581.0416, 603.0235,               167.0564, 189.0383, 150.0583, 172.0403, 171.0053, 192.9872,               130.0863, 152.0682, 768.1225, 790.1044),             ncol = 2, byrow = TRUE,             dimnames = list(c(\"IMP\", \"UMP\", \"UDP-glucuronate\",                                 \"1-Methylxanthine\", \"Methionine\",                                 \"Dihydroxyacetone phosphate\",                                 \"Pipecolic acid\", \"CoA\"),                              c(\"[M+H]+\", \"[M+Na]+\"))) result <- createStandardMixes(x, max_nstd = 4, min_nstd = 3, min_diff = 2,                                iterativeRandomization = TRUE)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal page for hidden aliases — hidden_aliases","title":"Internal page for hidden aliases — hidden_aliases","text":"S4 methods require documentation entry clutter index.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/hidden_aliases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal page for hidden aliases — hidden_aliases","text":"applicable","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":null,"dir":"Reference","previous_headings":"","what":"Chemical Formula Matching — matchFormula","title":"Chemical Formula Matching — matchFormula","text":"matchFormula method matches chemical formulas different inputs (parameter query target). comparison formulas normalized using MetaboCoreUtils::standardizeFormula(). Inputs can either character data.frame containing column formulas. case data.frames parameter formulaColname needs used specify name column containing chemical formulas.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chemical Formula Matching — matchFormula","text":"","code":"matchFormula(query, target, ...)  # S4 method for class 'character,character' matchFormula(query, target, BPPARAM = SerialParam())  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar' matchFormula(   query,   target,   formulaColname = c(\"formula\", \"formula\"),   BPPARAM = SerialParam() )  # S4 method for class 'character,data.frameOrSimilar' matchFormula(   query,   target,   formulaColname = \"formula\",   BPPARAM = SerialParam() )  # S4 method for class 'data.frameOrSimilar,character' matchFormula(   query,   target,   formulaColname = \"formula\",   BPPARAM = SerialParam() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chemical Formula Matching — matchFormula","text":"query character data.frame chemical formulas search. target character data.frame chemical formulas compare . ... currently ignored BPPARAM parallel processing setup. See BiocParallel::bpparam() details. formulaColname character name column containing chemical formulas. Can length 1 query target data.frames name column chemical formulas . different columns used, formulaColname[1] can used define column name query formulaColname[2] one target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chemical Formula Matching — matchFormula","text":"Matched object representing result.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Chemical Formula Matching — matchFormula","text":"Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchFormula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chemical Formula Matching — matchFormula","text":"","code":"## input formula query <- c(\"H12C6O6\", \"C11H12O2\", \"HN3\") target <- c(\"HCl\", \"C2H4O\", \"C6H12O6\")  query_df <- data.frame(     formula = c(\"H12C6O6\", \"C11H12O2\", \"HN3\"),     name = c(\"A\", \"B\", \"C\") ) target_df <- data.frame(     formula = c(\"HCl\", \"C2H4O\", \"C6H12O6\"),     name = c(\"D\", \"E\", \"F\") )  ## character vs character matches <- matchFormula(query, target) matchedData(matches) #> DataFrame with 3 rows and 3 columns #>            query  target     score #>           <AsIs>  <AsIs> <numeric> #> C6H12O6  H12C6O6 C6H12O6         1 #> NA      C11H12O2      NA        NA #> NA.1         HN3      NA        NA  ## data.frame vs data.frame matches <- matchFormula(query_df, target_df) matchedData(matches) #> DataFrame with 3 rows and 5 columns #>       formula        name target_formula target_name     score #>   <character> <character>    <character> <character> <numeric> #> 1     H12C6O6           A        C6H12O6           F         1 #> 2    C11H12O2           B             NA          NA        NA #> 3         HN3           C             NA          NA        NA ## data.frame vs character matches <- matchFormula(query_df, target) matchedData(matches) #> DataFrame with 3 rows and 4 columns #>       formula        name  target     score #>   <character> <character>  <AsIs> <numeric> #> 1     H12C6O6           A C6H12O6         1 #> 2    C11H12O2           B      NA        NA #> 3         HN3           C      NA        NA ## character vs data.frame matches <- matchFormula(query, target_df) matchedData(matches) #> DataFrame with 3 rows and 4 columns #>         query target_formula target_name     score #>        <AsIs>    <character> <character> <numeric> #> 3     H12C6O6        C6H12O6           F         1 #> NA   C11H12O2             NA          NA        NA #> NA.1      HN3             NA          NA        NA"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral matching — matchSpectra","title":"Spectral matching — matchSpectra","text":"matchSpectra method matches (compares) spectra query target based settings specified param returns result MatchedSpectra object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral matching — matchSpectra","text":"","code":"matchSpectra(query, target, param, ...)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral matching — matchSpectra","text":"query Spectra::Spectra object (experimental) spectra. target MS data compare . Can another Spectra::Spectra. param parameter object containing settings matching (e.g. eventual prefiltering settings, cut-value similarity spectra considered matching etc). ... optional parameters.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral matching — matchSpectra","text":"MatchedSpectra object spectra matching results.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spectral matching — matchSpectra","text":"Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching of numeric values — ValueParam","title":"Matching of numeric values — ValueParam","text":"matchValues method matches elements query target using different matching approaches depending parameter param. Generally, query expected contain MS experimental values (m/z possibly retention time) target reference values. query target can numeric, two dimensional array (data.frame, matrix DataFrame), SummarizedExperiment QFeatures, target can addition Spectra::Spectra() object. SummarizedExperiment, information matching expected object's rowData. QFeatures matching performed values present rowData one object's assays (needs specified assayQuery parameter - QFeatures used target name assay needs specified parameter assayTarget). target Spectra matching performed spectra variables object respective variable names need specified e.g. mzColname /rtColname. matchMz alias matchValues allow backward compatibility. Available param objects corresponding matching approaches : ValueParam: generic matching values query target given acceptable differences expressed ppm tolerance. query target numeric, parameter valueColname used specify name column contains values matched. function returns Matched() object. MzParam: match query m/z values reference compounds also m/z known. Matching performed similarly ValueParam . query target numeric, column name containing values compared must defined matchValues' parameter mzColname, defaults \"mz\". MzParam parameters tolerance ppm allow define maximal acceptable (constant m/z relative) difference query target m/z values. MzRtParam: match m/z retention time values query target. Parameters mzColname rtColname matchValues function allow define columns query target containing values (defaulting c(\"mz\", \"mz\") c(\"rt\", \"rt\"), respectively). MzRtParam parameters tolerance ppm meaning MzParam; MzRtParam parameter toleranceRt allows specify maximal acceptable difference query target retention time values. Mass2MzParam: match m/z values reference compounds (exact) mass known. matching, m/z values calculated compounds masses target table using adducts specified via Mass2MzParam adducts parameter (defaults adducts = \"[M+H]+\"). conversion adduct masses m/z values, matching performed similarly MzParam (.e. parameters ppm tolerance can used). query numeric, parameter mzColname matchValues can used specify column containing query's m/z values (defaults \"mz\"). target numeric, parameter massColname can used define column containing reference compound's masses (defaults \"exactmass\"). Mass2MzRtParam: match m/z retention time values reference compounds (exact) mass retention time known. matching, exact masses target converted m/z values Mass2MzParam. Matching performed similarly MzRtParam, .e. m/z retention times entities compared. matchValues' parameters mzColname, rtColname massColname columns containing m/z values (query), retention time values (query target) exact masses (target) can specified. Mz2MassParam: input values query target expected m/z values matching performed exact masses calculated (based provided adduct definitions). detail, m/z values query first converted masses MetaboCoreUtils::mz2mass() function based adducts defined queryAdducts (defaults \"[M+H]+\"). done m/z values target (adducts can defined targetAdducts defaults \"[M-H-]\"). Matching performed converted values similarly ValueParam. queryortargetare numeric, column containing m/z values can specified withmatchValues' parameter mzColname(defaults \"mz\"`). Mz2MassRtParam: Mz2MassParam additional comparison retention times query target. Parameters rtColname mzColname matchValues allow specify columns contain retention times m/z values, respectively.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching of numeric values — ValueParam","text":"","code":"ValueParam(tolerance = 0, ppm = 5)  MzParam(tolerance = 0, ppm = 5)  Mass2MzParam(adducts = c(\"[M+H]+\"), tolerance = 0, ppm = 5)  Mass2MzRtParam(adducts = c(\"[M+H]+\"), tolerance = 0, ppm = 5, toleranceRt = 0)  MzRtParam(tolerance = 0, ppm = 0, toleranceRt = 0)  Mz2MassParam(   queryAdducts = c(\"[M+H]+\"),   targetAdducts = c(\"[M-H]-\"),   tolerance = 0,   ppm = 5 )  Mz2MassRtParam(   queryAdducts = c(\"[M+H]+\"),   targetAdducts = c(\"[M+H]+\"),   tolerance = 0,   ppm = 5,   toleranceRt = 0 )  matchValues(query, target, param, ...)  # S4 method for class 'numeric,numeric,ValueParam' matchValues(query, target, param)  # S4 method for class 'numeric,data.frameOrSimilar,ValueParam' matchValues(   query,   target,   param,   valueColname = character(),   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,numeric,ValueParam' matchValues(   query,   target,   param,   valueColname = character(),   queryAssay = character() )  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,ValueParam' matchValues(   query,   target,   param,   valueColname = character(),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'numeric,numeric,Mass2MzParam' matchValues(query, target, param)  # S4 method for class 'numeric,data.frameOrSimilar,Mass2MzParam' matchValues(   query,   target,   param,   massColname = \"exactmass\",   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,numeric,Mass2MzParam' matchValues(query, target, param, mzColname = \"mz\", queryAssay = character())  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,Mass2MzParam' matchValues(   query,   target,   param,   mzColname = \"mz\",   massColname = \"exactmass\",   queryAssay = character(0),   targetAssay = character(0) )  # S4 method for class 'numeric,data.frameOrSimilar,MzParam' matchValues(query, target, param, mzColname = \"mz\", targetAssay = character())  # S4 method for class 'numeric,Spectra,MzParam' matchValues(query, target, param, mzColname = \"mz\", targetAssay = character())  # S4 method for class 'data.frameOrSimilar,numeric,MzParam' matchValues(query, target, param, mzColname = \"mz\", queryAssay = character())  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,MzParam' matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,Spectra,MzParam' matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,Mass2MzRtParam' matchValues(   query,   target,   param,   massColname = \"exactmass\",   mzColname = \"mz\",   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,MzRtParam' matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,Spectra,MzRtParam' matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'numeric,numeric,Mz2MassParam' matchValues(query, target, param)  # S4 method for class 'numeric,data.frameOrSimilar,Mz2MassParam' matchValues(query, target, param, mzColname = \"mz\", targetAssay = character())  # S4 method for class 'data.frameOrSimilar,numeric,Mz2MassParam' matchValues(query, target, param, mzColname = \"mz\", queryAssay = character())  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,Mz2MassParam' matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   queryAssay = character(),   targetAssay = character() )  # S4 method for class 'data.frameOrSimilar,data.frameOrSimilar,Mz2MassRtParam' matchValues(   query,   target,   param,   mzColname = c(\"mz\", \"mz\"),   rtColname = c(\"rt\", \"rt\"),   queryAssay = character(),   targetAssay = character() )"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching of numeric values — ValueParam","text":"tolerance param object: numeric(1) defining maximal acceptable absolute difference m/z (mass Mz2MassParam) consider matching. ppm param object: numeric(1) defining maximal acceptable m/z-dependent (mass-dependent Mz2MassParam) difference (parts-per-million) m/z values consider matching. adducts Mass2MzParam Mass2MzRtParam: either character adduct names MetaboCoreUtils::adducts() data.frame custom adduct definition. parameter used calculate m/z target compounds' masses. Custom adduct definitions can passed adduct parameter form data.frame. data.frame expected columns \"mass_add\" \"mass_multi\" defining additive multiplicative part calculation. See MetaboCoreUtils::adducts() expected format use MetaboCoreUtils::adductNames(\"positive\") MetaboCoreUtils::adductNames(\"negative\") valid adduct names. toleranceRt Mass2MzRtParam MzRtParam: numeric(1) defining maximal acceptable absolute difference retention time values consider matching. queryAdducts Mz2MassParam. Adducts used derive mass values query m/z values. expected format parameter adducts. targetAdducts Mz2MassParam. Adducts used derive mass values target m/z values. expected format parameter adducts. query feature table containing information MS1 features. Can numeric, data.frame, DataFrame, matrix, SummarizedExperiment QFeatures. expected contain m/z values can contain also variables. Matchings based m/z retention time can performed column retention times present query target. target compound table metabolites compare . expected types query. param parameter object defining matching approach containing settings approach. See description details. ... currently ignored. valueColname character specifying name column query /one targetwith desired values matching. parameter used param valueParam case must provided (unless query target numeric). can character(1) character(2) similar way mzColname. targetAssay character(1) specifying name assay provided QFeatures used matching (values assay's rowData used matching). used target instance QFeatures object. queryAssay character(1) specifying name assay provided QFeatures used matching (values assay's rowData used matching). used query instance QFeatures object. massColname character(1) name column target containing mass compounds. used param Mass2MzParam Mass2MzRtParam (target already numeric masses). Defaults massColname = \"exactmass\". mzColname character specifying name(s) column(s) query /targetwith m/z values. one among query target numeric (therefore need specify column name) query numeric param Mass2MzParam Mass2MzRtParam (therefore name column m/z needs specified query) mzColname expected character(1). query target numeric mzColname expected character(2) (character(1) last case two column names assumed ). specified assumed default name columns m/z values \"mz\". target Spectra::Spectra() object, name spectra variable used matching needs specified mzColname. rtColname character(2) name column containing compounds retention times query name one target. can also character(1) two names . used param MzRtParam Mass2MzRtParam. Defaults rtColname = c(\"rt\", \"rt\"). target Spectra::Spectra() object, name spectra variable used matching needs specified mzColname.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching of numeric values — ValueParam","text":"Matched object representing result. Depending param object different scores representing quality match provided. comprises absolute well relative differences (column/variables \"score\" \"ppm_error\" respectively). param Mz2MassParam, \"score\" \"ppm_error\" represent differences compared masses (calculated provided m/z values). param MzParam, MzRtParam, Mass2MzParam Mass2MzRtParam, \"score\" \"ppm_error\" represent absolute relative differences m/z values. Additionally, param either MzRtParam Mass2MzRtParam differences query target retention times matched element available column/variable \"score_rt\" returned Matched object. Negative values \"score\" (\"score_rt\") indicate m/z mass (retention time) query element smaller target element.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching of numeric values — ValueParam","text":"Andrea Vicini, Michael Witting","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/matchValues.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching of numeric values — ValueParam","text":"","code":"library(MetaboCoreUtils) #>  #> Attaching package: ‘MetaboCoreUtils’ #> The following object is masked from ‘package:CompoundDb’: #>  #>     mass2mz ## Create a simple \"target/reference\" compound table target_df <- data.frame(    name = c(\"Tryptophan\", \"Leucine\", \"Isoleucine\"),    formula = c(\"C11H12N2O2\", \"C6H13NO2\", \"C6H13NO2\"),    exactmass = c(204.089878, 131.094629, 131.094629) )  ## Create a \"feature\" table with m/z of features. We calculate m/z for ## certain adducts of some of the compounds in the reference table. fts <- data.frame(     feature_id = c(\"FT001\", \"FT002\", \"FT003\"),     mz = c(mass2mz(204.089878, \"[M+H]+\"),            mass2mz(131.094629, \"[M+H]+\"),            mass2mz(204.089878, \"[M+Na]+\") + 1e-6))  ## Define the parameters for the matching parm <- Mass2MzParam(     adducts = c(\"[M+H]+\", \"[M+Na]+\"),     tolerance = 0,     ppm = 20) res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## List the available variables/columns colnames(res) #> [1] \"feature_id\"       \"mz\"               \"target_name\"      \"target_formula\"   #> [5] \"target_exactmass\" \"adduct\"           \"score\"            \"ppm_error\"         ## feature_id and mz are from the query data frame, while target_name, ## target_formula and target_exactmass are from the query object (columns ## from the target object have a prefix *target_* added to the original ## column name. Columns adduct, score and ppm_error represent the results ## of the matching: adduct the adduct/ion of the original compound for which ## the m/z matches, score the absolute difference of the query and target ## m/z and ppm_error the relative difference in m/z values.  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 8 columns #>      feature_id        mz target_name target_formula target_exactmass #>     <character> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079  Tryptophan     C11H12N2O2          204.090 #>          adduct     score  ppm_error #>     <character> <numeric>  <numeric> #> 1        [M+H]+     0e+00 0.00000000 #> 2        [M+H]+     0e+00 0.00000000 #> 2.1      [M+H]+     0e+00 0.00000000 #> 3       [M+Na]+     1e-06 0.00440375  ## We have thus matches of FT002 to two different compounds (but with the ## same mass).  ## Individual columns can also be accessed with the $ operator: res$feature_id #> [1] \"FT001\" \"FT002\" \"FT002\" \"FT003\" res$target_name #> [1] \"Tryptophan\" \"Leucine\"    \"Isoleucine\" \"Tryptophan\" res$ppm_error #> [1] 0.000000000 0.000000000 0.000000000 0.004403752   ## We repeat the matching requiring an exact match parm <- Mass2MzParam(     adducts = c(\"[M+H]+\", \"[M+Na]+\"),     tolerance = 0,     ppm = 0) res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 3  #> Number of query objects: 3 (2 matched) #> Number of target objects: 3 (3 matched)  matchedData(res) #> DataFrame with 4 rows and 8 columns #>      feature_id        mz target_name target_formula target_exactmass #>     <character> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079          NA             NA               NA #>          adduct     score ppm_error #>     <character> <numeric> <numeric> #> 1        [M+H]+         0         0 #> 2        [M+H]+         0         0 #> 2.1      [M+H]+         0         0 #> 3            NA        NA        NA  ## The last feature could thus not be matched to any compound.  ## At last we use also different adduct definitions. parm <- Mass2MzParam(     adducts = c(\"[M+K]+\", \"[M+Li]+\"),     tolerance = 0,     ppm = 20) res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 0  #> Number of query objects: 3 (0 matched) #> Number of target objects: 3 (0 matched)  matchedData(res) #> DataFrame with 3 rows and 8 columns #>    feature_id        mz target_name target_formula target_exactmass      adduct #>   <character> <numeric> <character>    <character>        <numeric> <character> #> 1       FT001   205.097          NA             NA               NA          NA #> 2       FT002   132.102          NA             NA               NA          NA #> 3       FT003   227.079          NA             NA               NA          NA #>       score ppm_error #>   <numeric> <numeric> #> 1        NA        NA #> 2        NA        NA #> 3        NA        NA  ## No matches were found.  ## We can also match a \"feature\" table with a target data.frame taking into ## account both m/z and retention time values. target_df <- data.frame(   name = c(\"Tryptophan\", \"Leucine\", \"Isoleucine\"),   formula = c(\"C11H12N2O2\", \"C6H13NO2\", \"C6H13NO2\"),   exactmass = c(204.089878, 131.094629, 131.094629),   rt = c(150, 140, 140) )  fts <- data.frame(   feature_id = c(\"FT001\", \"FT002\", \"FT003\"),   mz = c(mass2mz(204.089878, \"[M+H]+\"),          mass2mz(131.094629, \"[M+H]+\"),          mass2mz(204.089878, \"[M+Na]+\") + 1e-6),   rt = c(150, 140, 150.1) )  ## Define the parameters for the matching parm <- Mass2MzRtParam(   adducts = c(\"[M+H]+\", \"[M+Na]+\"),   tolerance = 0,   ppm = 20,   toleranceRt = 0)  res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 3  #> Number of query objects: 3 (2 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 11 columns #>      feature_id        mz        rt target_name target_formula target_exactmass #>     <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079     150.1          NA             NA               NA #>     target_rt      adduct     score ppm_error  score_rt #>     <numeric> <character> <numeric> <numeric> <numeric> #> 1         150      [M+H]+         0         0         0 #> 2         140      [M+H]+         0         0         0 #> 2.1       140      [M+H]+         0         0         0 #> 3          NA          NA        NA        NA        NA  ## FT003 could not be matched to any compound, FT002 was matched to two ## different compounds (but with the same mass).  ## We repeat the matching allowing a positive tolerance for the matches ## between rt values  ## Define the parameters for the matching parm <- Mass2MzRtParam(   adducts = c(\"[M+H]+\", \"[M+Na]+\"),   tolerance = 0,   ppm = 20,   toleranceRt = 0.1)  res <- matchValues(fts, target_df, parm) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## Get the full matching result: matchedData(res) #> DataFrame with 4 rows and 11 columns #>      feature_id        mz        rt target_name target_formula target_exactmass #>     <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1         FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2         FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 2.1       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 3         FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>     target_rt      adduct     score  ppm_error  score_rt #>     <numeric> <character> <numeric>  <numeric> <numeric> #> 1         150      [M+H]+     0e+00 0.00000000       0.0 #> 2         140      [M+H]+     0e+00 0.00000000       0.0 #> 2.1       140      [M+H]+     0e+00 0.00000000       0.0 #> 3         150     [M+Na]+     1e-06 0.00440375       0.1  ## Also FT003 was matched in this case  ## It is also possible to match directly m/z values mz1 <- c(12, 343, 23, 231) mz2 <- mz1 + rnorm(4, sd = 0.001)  res <- matchValues(mz1, mz2, MzParam(tolerance = 0.001))  matchedData(res) #> DataFrame with 4 rows and 4 columns #>    query   target        score ppm_error #>   <AsIs>   <AsIs>    <numeric> <numeric> #> 1     12  11.9999  0.000108966  9.080580 #> 2    343 342.9999  0.000117242  0.341813 #> 3     23  23.0002 -0.000183083  7.960050 #> 4    231 231.0013 -0.001280555  5.543497  ## Matching with a SummarizedExperiment or a QFeatures work analogously, ## only that the matching is performed on the object's `rowData`.  ## Below we create a simple SummarizedExperiment with some random assay data. ## Note that results from a data preprocessing with the `xcms` package could ## be extracted as a `SummarizedExperiment` with the `quantify` method from ## the `xcms` package. library(SummarizedExperiment) se <- SummarizedExperiment(     assays = matrix(rnorm(12), nrow = 3, ncol = 4,     dimnames = list(NULL, c(\"A\", \"B\", \"C\", \"D\"))),     rowData = fts)  ## We can now perform the matching of this SummarizedExperiment against the ## target_df as before. res <- matchValues(se, target_df,     param = Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),         tolerance = 0, ppm = 20)) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## Getting the available columns colnames(res) #>  [1] \"feature_id\"       \"mz\"               \"rt\"               \"target_name\"      #>  [5] \"target_formula\"   \"target_exactmass\" \"target_rt\"        \"adduct\"           #>  [9] \"score\"            \"ppm_error\"         ## The query columns represent the columns of the object's `rowData` rowData(se) #> DataFrame with 3 rows and 3 columns #>    feature_id        mz        rt #>   <character> <numeric> <numeric> #> 1       FT001   205.097     150.0 #> 2       FT002   132.102     140.0 #> 3       FT003   227.079     150.1  ## matchedData also returns the query object's rowData along with the ## matching entries in the target object. matchedData(res) #> DataFrame with 4 rows and 10 columns #>    feature_id        mz        rt target_name target_formula target_exactmass #>   <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1       FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2       FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 3       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 4       FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>   target_rt      adduct     score  ppm_error #>   <numeric> <character> <numeric>  <numeric> #> 1       150      [M+H]+     0e+00 0.00000000 #> 2       140      [M+H]+     0e+00 0.00000000 #> 3       140      [M+H]+     0e+00 0.00000000 #> 4       150     [M+Na]+     1e-06 0.00440375  ## While `query` will return the full SummarizedExperiment. query(res) #> class: SummarizedExperiment  #> dim: 3 4  #> metadata(0): #> assays(1): '' #> rownames: NULL #> rowData names(3): feature_id mz rt #> colnames(4): A B C D #> colData names(0):  ## To illustrate use with a QFeatures object we first create a simple ## QFeatures object with two assays, `\"ions\"` representing the full feature ## data.frame and `\"compounds\"` a subset of it. library(QFeatures) #> Loading required package: MultiAssayExperiment #>  #> Attaching package: ‘QFeatures’ #> The following object is masked from ‘package:base’: #>  #>     sweep qf <- QFeatures(list(ions = se, compounds = se[2,]))  ## We can perform the same matching as before, but need to specify which of ## the assays in the QFeatures should be used for the matching. Below we ## perform the matching using the \"ions\" assay. res <- matchValues(qf, target_df, queryAssay = \"ions\",     param = Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\"),         tolerance = 0, ppm = 20)) res #> Object of class Matched  #> Total number of matches: 4  #> Number of query objects: 3 (3 matched) #> Number of target objects: 3 (3 matched)  ## colnames returns now the colnames of the `rowData` of the `\"ions\"` assay. colnames(res) #>  [1] \"feature_id\"       \"mz\"               \"rt\"               \"target_name\"      #>  [5] \"target_formula\"   \"target_exactmass\" \"target_rt\"        \"adduct\"           #>  [9] \"score\"            \"ppm_error\"         matchedData(res) #> DataFrame with 4 rows and 10 columns #>    feature_id        mz        rt target_name target_formula target_exactmass #>   <character> <numeric> <numeric> <character>    <character>        <numeric> #> 1       FT001   205.097     150.0  Tryptophan     C11H12N2O2          204.090 #> 2       FT002   132.102     140.0     Leucine       C6H13NO2          131.095 #> 3       FT002   132.102     140.0  Isoleucine       C6H13NO2          131.095 #> 4       FT003   227.079     150.1  Tryptophan     C11H12N2O2          204.090 #>   target_rt      adduct     score  ppm_error #>   <numeric> <character> <numeric>  <numeric> #> 1       150      [M+H]+     0e+00 0.00000000 #> 2       140      [M+H]+     0e+00 0.00000000 #> 3       140      [M+H]+     0e+00 0.00000000 #> 4       150     [M+Na]+     1e-06 0.00440375"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":null,"dir":"Reference","previous_headings":"","what":"Validating MatchedSpectra — validateMatchedSpectra","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"validateMatchedSpectra() function opens simple shiny application allows browse results stored MatchedSpectra object validate presented matches. query spectrum table matched target spectra shown (available) interactive mirror plot generated. Valid matches can selected using check box displayed mirror plot. Upon pushing \"Save & Close\" button app closed filtered MatchedSpectra returned, containing validated matches. Note column \"query_index_\" \"target_index_\" temporarily added query target Spectra object display interactive graphics easier identification compared spectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"","code":"validateMatchedSpectra(object)"},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"object non-empty instance class MatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"MatchedSpectra validated results.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"Carolin Huber, Michael Witting, Johannes Rainer","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/reference/validateMatchedSpectra.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validating MatchedSpectra — validateMatchedSpectra","text":"","code":"library(Spectra) ## Load test data fl <- system.file(\"TripleTOF-SWATH\", \"PestMix1_DDA.mzML\", package = \"msdata\") pest_ms2 <- filterMsLevel(Spectra(fl), 2L) pest_ms2 <- pest_ms2[c(808, 809, 945:955)] load(system.file(\"extdata\", \"minimb.RData\", package = \"MetaboAnnotation\"))  ## Normalize intensities and match spectra csp <- CompareSpectraParam(requirePrecursor = TRUE,                            THRESHFUN = function(x) x >= 0.7) norm_int <- function(x) {     x[, \"intensity\"] <- x[, \"intensity\"] / max(x[, \"intensity\"]) * 100     x } ms <- matchSpectra(addProcessing(pest_ms2, norm_int),                    addProcessing(minimb, norm_int), csp)  ## validate matches using the shiny app. Note: the call is only executed ## in interactive mode. if (interactive()) {     res <- validateMatchedSpectra(ms) }"},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-13","dir":"Changelog","previous_headings":"","what":"Changes in 1.13.1","title":"MetaboAnnotation 1.13","text":"Add parameter matchedPeaksCount CompareSpectraParam enables reporting number matched peaks matchSpectra() CompareSpectraParam. result reported column \"matched_peaks_count\".","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-11","dir":"Changelog","previous_headings":"","what":"Changes in 1.11.1","title":"MetaboAnnotation 1.11","text":"Fix reporting matched peaks MatchForwardReverseParam gnps-matching/similarity calculation (issue #119).","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-9","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.2","title":"MetaboAnnotation 1.9","text":"Fix missing ProtGenerics dependency.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-9-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.9.1","title":"MetaboAnnotation 1.9","text":"Add parameter scalePeaks plotSpectraMirror allow scaling peak intensities plotting.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.5","title":"MetaboAnnotation 1.7","text":"Add parameter addOriginalQueryIndex matchSpectra() allows add additional spectra variable query Spectra index original object (issue #114).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-7-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.4","title":"MetaboAnnotation 1.7","text":"Import setBackend() generic ProtGenerics.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-7-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.3","title":"MetaboAnnotation 1.7","text":"Add SingleMatchParam filterMatches allow selection () single match target element query element. Add new methods queryVariables targetVariables extract names variables (columns) query target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-7-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.2","title":"MetaboAnnotation 1.7","text":"Update Spectra objects within package new versions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-7-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.7.1","title":"MetaboAnnotation 1.7","text":"Add examples section vignette explaining use createStandardMixes.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.9","title":"MetaboAnnotation 1.5","text":"Addition global function createStandardMixes.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.8","title":"MetaboAnnotation 1.5","text":"Fix .randomize_grouping prevent collapsing matrix input single column.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.7","title":"MetaboAnnotation 1.5","text":"Add function .group_standards_iteration .randomize_grouping allow iteration matrix standards group dissimilar enough.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.6","title":"MetaboAnnotation 1.5","text":"Fix issue vignette. Thanks @RemyDeB fix.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.5","title":"MetaboAnnotation 1.5","text":"Update objects new definitions Spectra version 1.11.10.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.4","title":"MetaboAnnotation 1.5","text":"Add functions targetIndex queryIndex extract indices matched pairs query-target. Add examples section vignette explaining use.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-6","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.3","title":"MetaboAnnotation 1.5","text":"Add support matchValues matching data.frame Spectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-7","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.2","title":"MetaboAnnotation 1.5","text":"Fix vignette, examples unit tests using QFeatures. Import query AnnotationHub.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-5-8","dir":"Changelog","previous_headings":"","what":"Changes in 1.5.1","title":"MetaboAnnotation 1.5","text":"Add possibility select spectra variable retention time matching matchSpectra (issue #98).","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.2","title":"MetaboAnnotation 1.3","text":"Add mzR suggested package ensure package vignettes can built.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-3-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.3.1","title":"MetaboAnnotation 1.3","text":"Small changes matchSpectra avoid unnecessary object creation. Use backendBpparam disable parallel processing matchSpectra backend support .","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.6","title":"MetaboAnnotation 1.1","text":"scoreVariables function return names score variables Matched object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.5","title":"MetaboAnnotation 1.1","text":"Fix issues BioC build machines.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.4","title":"MetaboAnnotation 1.1","text":"matchSpectra: support CompDb parameter target. Add CompAnnotionSource classes support definition references annotation resources. Add CompDbSource class defining reference CompDb database. matchSpectra: support CompDbSource parameter target.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.3","title":"MetaboAnnotation 1.1","text":"Extend filterMatches framework (issue #86). ScoreThresholdParam added perform filtering matches based threshold scores.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.2","title":"MetaboAnnotation 1.1","text":"lapply endoapply methods (issue #84). lapply allows apply function subset matches query element returns corresponding list results. endoapply similar applies function returning Matched returns Matched representing updated matches.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-1-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.1","title":"MetaboAnnotation 1.1","text":"Extend filterMatches framework (issue #81). SelectMatchesParam TopRankedMatchesParam added perform respectively manual filtering keeping best ranked matches query element.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.15","title":"MetaboAnnotation 0.99","text":"Highlight query target spectra different colors validateMatchedSpectra. query /target type SummarizedExperiment supported Matched objects. MatchedSummarizedExperiment class removed. query /target type QFeatures supported Matched objects. Support SummarizedExperiment QFeatures query target parameters matchValues.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.14","title":"MetaboAnnotation 0.99","text":"Improve plotly-based mirror plots validateMatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.13","title":"MetaboAnnotation 0.99","text":"Fix issue matchedData working result objects matchValues, Mz2MassParam matchValues, Mz2MassRtParam (issue #69).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.12","title":"MetaboAnnotation 0.99","text":"Update plotly-based mirror plots validateMatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.11","title":"MetaboAnnotation 0.99","text":"Change matchMz matchValues (issue #65).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.10","title":"MetaboAnnotation 0.99","text":"Add validateMatchedSpectra manual inspection validation MatchedSpectra object.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.9","title":"MetaboAnnotation 0.99","text":"Add setBackend MatchedSpectra objects.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.8","title":"MetaboAnnotation 0.99","text":"Add matchMz, Mz2MassParam matchMz, Mz2MassRtParam. (issue #56).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.7","title":"MetaboAnnotation 0.99","text":"Add formula matching functions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.5","title":"MetaboAnnotation 0.99","text":"Add parameter ... plotSpectraMirror. Definitions “score”, “score_rt” changed difference (sign) query target m/z retention time respectively. \"ppm_error\" becomes error without sign.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.4","title":"MetaboAnnotation 0.99","text":"Add matches m/z error (variable \"ppm_error\") Matched object returned matchMz.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-99-11","dir":"Changelog","previous_headings":"","what":"Changes in 0.99.3","title":"MetaboAnnotation 0.99","text":"Address Herve’s comments.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.11","title":"MetaboAnnotation 0.2","text":"Fix calculation correct number rows/columns plot plotSpectraMirror.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.10","title":"MetaboAnnotation 0.2","text":"Add parameter toleranceRt CompareSpectraParam enable retention time-based pre-filtering (issue #35).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.9","title":"MetaboAnnotation 0.2","text":"Add support manually defined adducts Mass2MzParam (issue #41).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.8","title":"MetaboAnnotation 0.2","text":"Add parameter THRESHFUN_REVERSE MatchForwardReverseParam allow filtering results forward reverse score (issue #37).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.7","title":"MetaboAnnotation 0.2","text":"Performance improvement matchSpectra precursor m/z filter used (issue #38). Report number matching peaks matchSpectra,MatchForwardReverseParam (issue #36).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.6","title":"MetaboAnnotation 0.2","text":"Fix bug matchSpectra wrongly calculating acceptable m/z difference tolerance > 0 (issue #34). Fix proposed Hugo Varet (@hvaret).","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.5","title":"MetaboAnnotation 0.2","text":"Improve performance matchMz. Rename queryColumn targetColumn queryColname targetColname.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-7","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.4","title":"MetaboAnnotation 0.2","text":"Support data.frame, DataFrame matrix matchMz. Add addMatches filterMatches functions.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-8","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.3","title":"MetaboAnnotation 0.2","text":"Fixes MatchedSpectra.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-9","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.2","title":"MetaboAnnotation 0.2","text":"Add MatchedSummarizedExperiment.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-10","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.1","title":"MetaboAnnotation 0.2","text":"Rename TargetMass2MzParam Mass2MzParam.","code":""},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-2-11","dir":"Changelog","previous_headings":"","what":"Changes in 0.2.0","title":"MetaboAnnotation 0.2","text":"Add support matching m/z m/z m/z addition retention times matchMz.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/MetaboAnnotation/news/index.html","id":"changes-in-0-0","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.4","title":"MetaboAnnotation 0.0","text":"Fix vignette, documentations unit tests.","code":""}]
